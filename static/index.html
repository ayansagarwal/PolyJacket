<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PolyJacket - GT IM Prediction Market</title>
</head>
<body>
  <div id="app"></div>
  
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

  <script>
    // Custom Chart.js interaction mode: show tooltip at any x hover position
    // for stepped lines (finds last known value at cursor position).
    Chart.Interaction.modes.steppedHover = function(chart, e, options) {
      const mouseX = e.x;
      const items = [];
      chart.data.datasets.forEach(function(dataset, datasetIndex) {
        const meta = chart.getDatasetMeta(datasetIndex);
        if (!meta.visible) return;
        const pts = meta.data;
        // Walk forward; keep the last index whose pixel x <= cursor x
        let found = -1;
        for (let i = 0; i < pts.length; i++) {
          if (pts[i].x <= mouseX) found = i;
          else break;
        }
        if (found >= 0) {
          items.push({ datasetIndex: datasetIndex, index: found, element: pts[found] });
        }
      });
      return items;
    };
  </script>
  
  <script type="module">
    const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;
    
    createApp({
      setup() {
        // Authentication State
        const isLoggedIn = ref(false);
        const user = ref(null);
        const token = ref(null);
        const showAuthModal = ref(false);
        const authMode = ref('login'); // 'login' or 'register'
        const authUsername = ref('');
        const authEmail = ref('');
        const authPassword = ref('');
        const authError = ref('');
        const authProcessing = ref(false);
        
        // State
        const loading = ref(true);
        const error = ref(null);
        const markets = ref([]);
        const portfolio = ref(null);
        const userBalance = ref(0);
        const selectedSport = ref('All');
        const selectedDate = ref('All');
        const activeTab = ref('markets'); // 'markets' or 'portfolio'
        const showTradeModal = ref(false);
        const selectedMarket = ref(null);
        const tradeOutcome = ref('home');
        const tradeAmount = ref(100);
        const tradeProcessing = ref(false);
        const tradeResult = ref(null);

        // Sell state
        const showSellModal = ref(false);
        const sellPosition = ref(null);   // position being sold
        const sellMarket = ref(null);     // corresponding market object
        const sellOutcome = ref('home');  // 'home' or 'away'
        const sellShares = ref(0);
        const sellProcessing = ref(false);
        const sellResult = ref(null);
        const sellPreview = ref(null);    // estimated tokens to receive

        // Price chart state
        const showPriceChart = ref(false);
        const priceChartData = ref(null);
        const priceChartInstance = ref(null);
        const priceChartCanvasRef = ref(null); // Vue template ref ‚Äî always current DOM element
        const chartRawHistory = ref([]);  // full history, unfiltered
        const chartView = ref('1w');      // '1h', '1d', '1w'

        // Computed
        const uniqueSports = computed(() => {
          const sports = new Set(markets.value.map(m => m.sport));
          return Array.from(sports).sort();
        });

        const uniqueDates = computed(() => {
          const dates = new Set(markets.value.map(m => m.game_date).filter(d => d));
          return Array.from(dates).sort();
        });

        // Parse a market's date + time into a sortable timestamp
        function gameDateTime(m) {
          try {
            const [mo, da, yr] = (m.game_date || '').split('/');
            const t = m.game_time || '';
            if (!t || t === 'TBD') return new Date(yr, mo - 1, da, 23, 59, 0).getTime();
            if (t === 'FINAL' || t === 'BYE' || t === 'FORFEIT') return new Date(yr, mo - 1, da, 23, 59, 59).getTime();
            return new Date(`${m.game_date} ${t}`).getTime();
          } catch { return Infinity; }
        }

        const filteredMarkets = computed(() => {
          let filtered = markets.value;
          
          // Filter by sport
          if (selectedSport.value !== 'All') {
            filtered = filtered.filter(m => m.sport === selectedSport.value);
          }
          
          // Filter by date
          if (selectedDate.value !== 'All') {
            filtered = filtered.filter(m => m.game_date === selectedDate.value);
          }

          // Sort: open first, then closed, then settled; soonest game first within each group
          const statusOrder = { open: 0, closed: 1, settled: 2 };
          filtered = [...filtered].sort((a, b) => {
            const sd = (statusOrder[a.status] ?? 1) - (statusOrder[b.status] ?? 1);
            if (sd !== 0) return sd;
            return gameDateTime(a) - gameDateTime(b);
          });
          
          return filtered;
        });

        const openMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'open')
        );

        const closedMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'closed')
        );

        const settledMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'settled')
        );

        // Removed totalValue - now just showing balance

        const openPositions = computed(() => {
          if (!portfolio.value) return [];
          return portfolio.value.open_positions || [];
        });

        const settledPositions = computed(() => {
          if (!portfolio.value) return [];
          return portfolio.value.settled_positions || [];
        });

        // Helper to get today's date in the same format as game dates
        function getTodayDate() {
          const today = new Date();
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = months[today.getMonth()];
          const day = today.getDate();
          const year = today.getFullYear();
          return `${month} ${day}, ${year}`;
        }

        // Authentication Methods
        function checkAuth() {
          const savedToken = localStorage.getItem('auth_token');
          const savedUser = localStorage.getItem('user');
          if (savedToken && savedUser) {
            token.value = savedToken;
            user.value = JSON.parse(savedUser);
            isLoggedIn.value = true;
          }
        }

        async function login() {
          try {
            authProcessing.value = true;
            authError.value = '';
            const response = await fetch('/api/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                username: authUsername.value,
                password: authPassword.value
              })
            });
            
            if (!response.ok) {
              const data = await response.json();
              throw new Error(data.detail || 'Login failed');
            }
            
            const data = await response.json();
            token.value = data.access_token;
            user.value = { username: data.username, user_id: data.user_id };
            isLoggedIn.value = true;
            
            localStorage.setItem('auth_token', data.access_token);
            localStorage.setItem('user', JSON.stringify(user.value));
            
            showAuthModal.value = false;
            authUsername.value = '';
            authPassword.value = '';
            
            await fetchUser();
            await fetchPortfolio();
            await fetchMarkets();
          } catch (err) {
            authError.value = err.message;
          } finally {
            authProcessing.value = false;
          }
        }

        async function register() {
          try {
            authProcessing.value = true;
            authError.value = '';
            const response = await fetch('/api/register', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                username: authUsername.value,
                email: authEmail.value,
                password: authPassword.value
              })
            });
            
            if (!response.ok) {
              const data = await response.json();
              throw new Error(data.detail || 'Registration failed');
            }
            
            const data = await response.json();
            token.value = data.access_token;
            user.value = { username: data.username, user_id: data.user_id };
            isLoggedIn.value = true;
            
            localStorage.setItem('auth_token', data.access_token);
            localStorage.setItem('user', JSON.stringify(user.value));
            
            showAuthModal.value = false;
            authUsername.value = '';
            authEmail.value = '';
            authPassword.value = '';
            
            await fetchUser();
            await fetchPortfolio();
            await fetchMarkets();
          } catch (err) {
            authError.value = err.message;
          } finally {
            authProcessing.value = false;
          }
        }

        function logout() {
          token.value = null;
          user.value = null;
          isLoggedIn.value = false;
          localStorage.removeItem('auth_token');
          localStorage.removeItem('user');
          portfolio.value = null;
          userBalance.value = 0;
        }

        function openAuthModal(mode = 'login') {
          authMode.value = mode;
          authError.value = '';
          showAuthModal.value = true;
        }

        // Methods
        async function fetchMarkets() {
          try {
            loading.value = true;
            error.value = null;
            const response = await fetch('/api/markets');
            const data = await response.json();
            if (data.success) {
              markets.value = data.markets;
              // Sort by status: open first, then closed, then settled
              markets.value.sort((a, b) => {
                const statusOrder = { 'open': 0, 'closed': 1, 'settled': 2 };
                return statusOrder[a.status] - statusOrder[b.status];
              });
              
              // Auto-select today's date if available
              const todayDate = getTodayDate();
              const dates = new Set(markets.value.map(m => m.game_date).filter(d => d));
              if (dates.has(todayDate) && selectedDate.value === 'All') {
                selectedDate.value = todayDate;
              }
            } else {
              error.value = 'Failed to load markets';
            }
          } catch (err) {
            error.value = 'Error connecting to server';
            console.error(err);
          } finally {
            loading.value = false;
          }
        }

        async function fetchUser() {
          if (!token.value) return;
          try {
            const response = await fetch('/api/user', {
              headers: {
                'Authorization': `Bearer ${token.value}`
              }
            });
            if (response.ok) {
              const data = await response.json();
              userBalance.value = data.balance;
              user.value = {
                ...user.value,
                email: data.email,
                balance: data.balance
              };
            }
          } catch (err) {
            console.error('Error fetching user:', err);
          }
        }

        async function fetchPortfolio() {
          if (!token.value) return;
          try {
            const response = await fetch('/api/portfolio', {
              headers: {
                'Authorization': `Bearer ${token.value}`
              }
            });
            if (response.ok) {
              const data = await response.json();
              portfolio.value = data;
              userBalance.value = data.balance;
            }
          } catch (err) {
            console.error('Error fetching portfolio:', err);
          }
        }

        // ---- Sell functionality ----
        function openSellModal(position, outcome) {
          const market = markets.value.find(m => m.market_id === position.market_id);
          if (!market) return;
          sellPosition.value = position;
          sellMarket.value = market;
          sellOutcome.value = outcome;
          const maxShares = outcome === 'home' ? position.home_shares : position.away_shares;
          sellShares.value = parseFloat(maxShares.toFixed(4));
          sellResult.value = null;
          updateSellPreview();
          showSellModal.value = true;
        }

        function closeSellModal() {
          showSellModal.value = false;
          sellPosition.value = null;
          sellMarket.value = null;
          sellResult.value = null;
          sellPreview.value = null;
        }

        function updateSellPreview() {
          if (!sellMarket.value || !sellShares.value || sellShares.value <= 0) {
            sellPreview.value = null;
            return;
          }
          // LMSR sell-back: before - after of cost function (mirrors backend)
          const b = 100;
          const shares = parseFloat(sellShares.value);
          let currentSide, otherSide;
          if (sellOutcome.value === 'home') {
            currentSide = sellMarket.value.home_shares;
            otherSide   = sellMarket.value.away_shares;
          } else {
            currentSide = sellMarket.value.away_shares;
            otherSide   = sellMarket.value.home_shares;
          }
          const before = b * Math.log(Math.exp(currentSide / b) + Math.exp(otherSide / b));
          const after  = b * Math.log(Math.exp((currentSide - shares) / b) + Math.exp(otherSide / b));
          sellPreview.value = Math.max(0, before - after);
        }

        async function executeSell() {
          if (!token.value) return;
          try {
            sellProcessing.value = true;
            sellResult.value = null;
            const response = await fetch('/api/sell', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                market_id: sellPosition.value.market_id,
                outcome: sellOutcome.value,
                shares: parseFloat(sellShares.value)
              })
            });
            const data = await response.json();
            if (response.ok && data.success) {
              sellResult.value = { success: true, message: data.message };
              await fetchMarkets();
              await fetchPortfolio();
              setTimeout(() => {
                closeSellModal();
              }, 1800);
            } else {
              sellResult.value = { success: false, message: data.detail || 'Sell failed' };
            }
          } catch (err) {
            sellResult.value = { success: false, message: 'Error executing sell' };
          } finally {
            sellProcessing.value = false;
          }
        }

        // ---- Price chart ----

        // Parse SQLite UTC timestamp string ‚Üí local Date object
        function parseUTC(ts) {
          if (!ts) return new Date();
          // SQLite CURRENT_TIMESTAMP: "YYYY-MM-DD HH:MM:SS" ‚Äî treat as UTC
          return new Date(ts.trim().replace(' ', 'T') + 'Z');
        }

        async function openPriceChart(market) {
          selectedMarket.value = market;
          showPriceChart.value = true;
          priceChartData.value = null;
          chartView.value = '1w';
          chartRawHistory.value = [];
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          try {
            const res = await fetch(`/api/markets/${market.market_id}/history`);
            const data = await res.json();
            if (data.success) {
              priceChartData.value = data.history;
              chartRawHistory.value = data.history;
              await nextTick();
              renderPriceChart(data.history, market);
            } else {
              priceChartData.value = [];
            }
          } catch (err) {
            console.error('Failed to load price history:', err);
            priceChartData.value = [];
          }
        }

        function closePriceChart() {
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          showPriceChart.value = false;
          priceChartData.value = null;
          chartRawHistory.value = [];
        }

        function setChartView(v) {
          chartView.value = v;
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          // One rAF lets the browser flush the canvas clear that destroy() triggers,
          // so the new Chart() always gets a clean, uncorrupted 2D context.
          requestAnimationFrame(() => {
            renderPriceChart(chartRawHistory.value, selectedMarket.value);
          });
        }

        function renderPriceChart(history, market) {
          // Use Vue template ref so we always get the current live canvas element
          const canvas = priceChartCanvasRef.value;
          if (!canvas || !history.length) return;

          // Destroy any lingering instance on THIS canvas before creating a new one
          if (priceChartInstance.value) {
            try { priceChartInstance.value.destroy(); } catch (_) {}
            priceChartInstance.value = null;
          }

          // Build time-based data points, converting UTC ‚Üí local Date objects
          const points = history.map(h => ({
            x: parseUTC(h.timestamp),
            home: h.home_price,
            away: h.away_price
          }));

          // Determine x-axis window based on selected view
          const now = new Date();
          let xMin;
          if (chartView.value === '1h') {
            xMin = new Date(now.getTime() - 3600 * 1000);
          } else if (chartView.value === '1d') {
            xMin = new Date(now.getTime() - 86400 * 1000);
          } else {
            xMin = new Date(now.getTime() - 7 * 86400 * 1000);
          }

          // Split into points before and within the window
          const before = points.filter(p => p.x < xMin);
          const after  = points.filter(p => p.x >= xMin);

          // Left anchor: last known price before the window, placed exactly at xMin.
          // If no prior point exists, use the very first point's price (opening price).
          const leftSrc = before.length ? before[before.length - 1] : (points[0] || { home: 50, away: 50 });
          const leftAnchor = { x: new Date(xMin), home: leftSrc.home, away: leftSrc.away };

          // Right anchor: extend last known price to 'now' so the line fills the window.
          const rightSrc = after.length ? after[after.length - 1] : leftSrc;
          const rightAnchor = { x: new Date(now), home: rightSrc.home, away: rightSrc.away };

          // Combine: left anchor ‚Üí points within window ‚Üí right anchor
          // Deduplicate in case a point lands exactly on xMin or now
          const visiblePoints = [leftAnchor, ...after, rightAnchor];

          // Determine tick granularity for readability
          let timeUnit, tooltipFmt;
          if (chartView.value === '1h') {
            timeUnit = 'minute';
            tooltipFmt = 'h:mm a';
          } else if (chartView.value === '1d') {
            timeUnit = 'hour';
            tooltipFmt = 'h:mm a';
          } else {
            timeUnit = 'day';
            tooltipFmt = 'MMM d, h:mm a';
          }

          priceChartInstance.value = new Chart(canvas, {
            type: 'line',
            data: {
              datasets: [
                {
                  label: `${market.home_team}`,
                  data: visiblePoints.map(p => ({ x: p.x, y: p.home })),
                  borderColor: '#667eea',
                  backgroundColor: 'rgba(102,126,234,0.08)',
                  stepped: 'before',
                  tension: 0,
                  fill: true,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  pointHoverBackgroundColor: '#667eea',
                  borderWidth: 2,
                  yAxisID: 'yHome'
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'steppedHover', intersect: false, axis: 'x' },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    title: items => items[0] ? items[0].label : '',
                    label: ctx => {
                      const home = ctx.parsed.y;
                      const away = 100 - home;
                      return [
                        `${market.home_team}: ${home.toFixed(1)}¬¢`,
                        `${market.away_team}: ${away.toFixed(1)}¬¢`
                      ];
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: timeUnit,
                    tooltipFormat: tooltipFmt,
                    displayFormats: {
                      minute: 'h:mm a',
                      hour:   'h a',
                      day:    'MMM d'
                    }
                  },
                  min: xMin,
                  max: now,
                  ticks: { maxTicksLimit: 7, maxRotation: 20 },
                  grid: { color: 'rgba(0,0,0,0.04)' }
                },
                yHome: {
                  position: 'left',
                  min: 0,
                  max: 100,
                  ticks: { callback: v => v + '¬¢' },
                  title: { display: true, text: `${market.home_team} ‚Üí`, color: '#667eea', font: { weight: 'bold' } },
                  grid: { color: 'rgba(0,0,0,0.06)' }
                },
                yAway: {
                  position: 'right',
                  min: 0,
                  max: 100,
                  ticks: { callback: v => (100 - v) + '¬¢' },
                  title: { display: true, text: `‚Üê ${market.away_team}`, color: '#f97316', font: { weight: 'bold' } },
                  grid: { drawOnChartArea: false }
                }
              }
            }
          });
        }


        async function executeTrade() {
          if (!token.value) {
            openAuthModal('login');
            return;
          }
          
          try {
            tradeProcessing.value = true;
            tradeResult.value = null;
            
            const response = await fetch('/api/trade', {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                market_id: selectedMarket.value.market_id,
                outcome: tradeOutcome.value,
                amount: parseFloat(tradeAmount.value)
              })
            });

            const data = await response.json();
            
            if (response.ok && data.success) {
              tradeResult.value = {
                success: true,
                message: `Successfully purchased ${data.shares_purchased} shares at ${data.price_per_share.toFixed(2)} tokens per share!`,
                data: data
              };
              
              // Refresh data
              await fetchMarkets();
              await fetchPortfolio();
              
              // Reset form
              setTimeout(() => {
                showTradeModal.value = false;
                tradeResult.value = null;
                tradeAmount.value = 100;
              }, 2000);
            } else {
              tradeResult.value = {
                success: false,
                message: data.detail || 'Trade failed'
              };
            }
          } catch (err) {
            tradeResult.value = {
              success: false,
              message: 'Error executing trade'
            };
            console.error(err);
          } finally {
            tradeProcessing.value = false;
          }
        }

        function openTradeModal(market) {
          selectedMarket.value = market;
          showTradeModal.value = true;
          tradeOutcome.value = 'home';
          tradeAmount.value = 100;
          tradeResult.value = null;
        }

        function closeTradeModal() {
          showTradeModal.value = false;
          selectedMarket.value = null;
          tradeResult.value = null;
        }

        function getStatusColor(status) {
          return {
            'open': 'status-open',
            'closed': 'status-closed',
            'settled': 'status-settled'
          }[status] || '';
        }

        function getStatusIcon(status) {
          return {
            'open': 'üü¢',
            'closed': 'üî¥',
            'settled': '‚úÖ'
          }[status] || '';
        }

        function getStatusText(status) {
          return {
            'open': 'Open',
            'closed': 'Closed',
            'settled': 'Settled'
          }[status] || status;
        }

        function formatTokens(amount) {
          return `${amount.toFixed(0)} ü™ô`;
        }

        // Initialize
        onMounted(async () => {
          checkAuth();
          await fetchMarkets();
          if (isLoggedIn.value) {
            await fetchUser();
            await fetchPortfolio();
          }
        });

        return {
          // Auth
          isLoggedIn,
          user,
          showAuthModal,
          authMode,
          authUsername,
          authEmail,
          authPassword,
          authError,
          authProcessing,
          login,
          register,
          logout,
          openAuthModal,
          // State
          loading,
          error,
          markets,
          portfolio,
          userBalance,
          selectedSport,
          selectedDate,
          uniqueDates,
          activeTab,
          showTradeModal,
          selectedMarket,
          tradeOutcome,
          tradeAmount,
          tradeProcessing,
          tradeResult,
          uniqueSports,
          filteredMarkets,
          openMarkets,
          closedMarkets,
          settledMarkets,
          openPositions,
          settledPositions,
          // Methods
          fetchMarkets,
          fetchPortfolio,
          executeTrade,
          openTradeModal,
          closeTradeModal,
          getStatusColor,
          getStatusIcon,
          getStatusText,
          formatTokens,
          // Sell
          showSellModal,
          sellPosition,
          sellMarket,
          sellOutcome,
          sellShares,
          sellProcessing,
          sellResult,
          sellPreview,
          openSellModal,
          closeSellModal,
          updateSellPreview,
          executeSell,
          // Price chart
          showPriceChart,
          priceChartData,
          priceChartCanvasRef,
          chartView,
          openPriceChart,
          closePriceChart,
          setChartView
        };
      },
      
      template: `
        <div class="app-container">
          <header class="header">
            <div class="header-content">
              <div class="branding">
                <h1>‚ö° PolyJacket</h1>
                <p class="subtitle">GT Intramural Prediction Markets</p>
              </div>
              <div class="wallet">
                <div v-if="isLoggedIn" class="user-info">
                  <div class="balance">
                    <span class="label">Balance</span>
                    <span class="amount">{{ formatTokens(userBalance) }}</span>
                  </div>
                  <div class="username">
                    <span>üë§ {{ user.username }}</span>
                    <button class="btn-logout" @click="logout">Logout</button>
                  </div>
                </div>
                <div v-else class="auth-buttons">
                  <button class="btn-login" @click="openAuthModal('login')">Login</button>
                  <button class="btn-register" @click="openAuthModal('register')">Register</button>
                </div>
              </div>
            </div>
          </header>

          <!-- Navigation Tabs -->
          <div class="tabs">
            <button 
              :class="['tab', { active: activeTab === 'markets' }]"
              @click="activeTab = 'markets'"
            >
              üìä Markets ({{ markets.length }})
            </button>
            <button 
              :class="['tab', { active: activeTab === 'portfolio' }]"
              @click="activeTab = 'portfolio'"
            >
              üíº Portfolio ({{ openPositions.length }})
            </button>
          </div>

          <!-- Loading State -->
          <div v-if="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading markets...</p>
          </div>

          <!-- Error State -->
          <div v-else-if="error" class="error">
            <p>‚ùå {{ error }}</p>
            <button @click="fetchMarkets" class="retry-btn">Retry</button>
          </div>

          <!-- Markets Tab -->
          <div v-else-if="activeTab === 'markets'" class="markets-tab">
            <!-- Date Filter (Top Bar) -->
            <div class="date-filter-bar">
              <button 
                :class="['date-chip', { active: selectedDate === 'All' }]"
                @click="selectedDate = 'All'"
              >
                All Dates
              </button>
              <button 
                v-for="date in uniqueDates" 
                :key="date"
                :class="['date-chip', { active: selectedDate === date }]"
                @click="selectedDate = date"
              >
                {{ date }}
              </button>
            </div>

            <!-- Markets Container -->
            <div class="markets-container">
              <!-- Sport Sidebar -->
              <div class="sport-sidebar">
                <h3 class="sidebar-title">üèÄ Filter by Sport</h3>
                <div class="sport-list">
                  <button 
                    :class="['sport-btn', { active: selectedSport === 'All' }]"
                    @click="selectedSport = 'All'"
                  >
                    All Sports
                  </button>
                  <button 
                    v-for="sport in uniqueSports" 
                    :key="sport"
                    :class="['sport-btn', { active: selectedSport === sport }]"
                    @click="selectedSport = sport"
                  >
                    {{ sport }}
                  </button>
                </div>
              </div>

              <!-- Markets Content -->
              <div class="markets-content">

            <!-- Open Markets -->
            <div v-if="openMarkets.length > 0" class="market-section">
              <h2 class="section-title">üü¢ Open Markets</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in openMarkets" 
                  :key="market.market_id"
                  class="market-card open"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-open">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div class="game-info">
                      <span>üìÖ {{ market.game_date }}</span>
                      <span>‚è∞ {{ market.game_time }}</span>
                    </div>
                  </div>

                  <div class="odds-section">
                    <div class="outcome-card home">
                      <div class="team-name">{{ market.home_team }}</div>
                      <div class="elo-badge" v-if="market.home_elo != null">Elo {{ market.home_elo }}</div>
                      <div class="price">{{ market.home_price.toFixed(1) }}¬¢</div>
                      <button 
                        class="buy-btn"
                        @click="openTradeModal(market); tradeOutcome = 'home'"
                      >
                        Buy
                      </button>
                    </div>
                    
                    <div class="outcome-card away">
                      <div class="team-name">{{ market.away_team }}</div>
                      <div class="elo-badge" v-if="market.away_elo != null">Elo {{ market.away_elo }}</div>
                      <div class="price">{{ market.away_price.toFixed(1) }}¬¢</div>
                      <button 
                        class="buy-btn"
                        @click="openTradeModal(market); tradeOutcome = 'away'"
                      >
                        Buy
                      </button>
                    </div>
                  </div>

                  <div class="market-stats">
                    <span>Volume: {{ formatTokens(market.total_volume) }}</span>
                    <button class="chart-btn" @click="openPriceChart(market)">üìà Price History</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- Closed Markets -->
            <div v-if="closedMarkets.length > 0" class="market-section">
              <h2 class="section-title">üî¥ Closed Markets (Awaiting Results)</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in closedMarkets" 
                  :key="market.market_id"
                  class="market-card closed"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-closed">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div class="game-info">
                      <span>üìÖ {{ market.game_date }}</span>
                      <span>‚è∞ {{ market.game_time }}</span>
                    </div>
                  </div>

                  <div class="odds-section disabled">
                    <div class="outcome-card home">
                      <div class="team-name">{{ market.home_team }}</div>
                      <div class="elo-badge" v-if="market.home_elo != null">Elo {{ market.home_elo }}</div>
                      <div class="price">{{ market.home_price.toFixed(1) }}¬¢</div>
                    </div>
                    
                    <div class="outcome-card away">
                      <div class="team-name">{{ market.away_team }}</div>
                      <div class="elo-badge" v-if="market.away_elo != null">Elo {{ market.away_elo }}</div>
                      <div class="price">{{ market.away_price.toFixed(1) }}¬¢</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Settled Markets -->
            <div v-if="settledMarkets.length > 0" class="market-section">
              <h2 class="section-title">‚úÖ Settled Markets</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in settledMarkets" 
                  :key="market.market_id"
                  class="market-card settled"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-settled">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div v-if="market.home_score && market.away_score && market.home_score !== '--' && market.away_score !== '--'" class="final-score">
                      <span :class="['score', market.winner === 'home' ? 'winner' : 'loser']">{{ market.home_score }}</span>
                      <span class="score-separator">-</span>
                      <span :class="['score', market.winner === 'away' ? 'winner' : 'loser']">{{ market.away_score }}</span>
                    </div>
                  </div>

                  <div class="settlement-info">
                    <div :class="['winner-banner', market.winner === 'home' ? 'home' : 'away']">
                      <span class="trophy">üèÜ</span>
                      <span>{{ market.winner === 'home' ? market.home_team : market.away_team }} Won</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div v-if="filteredMarkets.length === 0" class="no-markets">
              <p>No markets available</p>
            </div>
            </div>
            <!-- End markets-content -->
            </div>
            <!-- End markets-container -->
          </div>
          <!-- End markets-tab -->

          <!-- Portfolio Tab -->
          <div v-else-if="activeTab === 'portfolio'" class="portfolio-container">
            <div v-if="openPositions.length === 0 && settledPositions.length === 0" class="no-positions">
              <h2>üì≠ No Positions Yet</h2>
              <p>Visit the Markets tab to start predicting!</p>
            </div>

            <div v-else>
              <!-- Open Positions -->
              <div v-if="openPositions.length > 0" class="positions-section">
                <h2 class="section-title">üìä Open Positions</h2>
                <div class="positions-grid">
                  <div 
                    v-for="position in openPositions" 
                    :key="position.market_id"
                    class="position-card"
                  >
                    <h3>{{ position.game }}</h3>
                    <div class="position-details">
                      <div v-if="position.home_shares > 0" class="shares-info">
                        <span class="label">Home Shares:</span>
                        <span class="value">{{ position.home_shares.toFixed(2) }} @ {{ position.avg_home_price.toFixed(1) }}¬¢</span>
                      </div>
                      <div v-if="position.away_shares > 0" class="shares-info">
                        <span class="label">Away Shares:</span>
                        <span class="value">{{ position.away_shares.toFixed(2) }} @ {{ position.avg_away_price.toFixed(1) }}¬¢</span>
                      </div>
                      <div class="shares-info highlight">
                        <span class="label">Potential Payout:</span>
                        <span class="value">{{ formatTokens(position.potential_payout) }}</span>
                      </div>
                      <div class="sell-actions">
                        <button v-if="position.home_shares > 0" class="sell-btn" @click="openSellModal(position, 'home')">
                          Sell Home ({{ position.home_shares.toFixed(2) }})
                        </button>
                        <button v-if="position.away_shares > 0" class="sell-btn" @click="openSellModal(position, 'away')">
                          Sell Away ({{ position.away_shares.toFixed(2) }})
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Settled Positions -->
              <div v-if="settledPositions.length > 0" class="positions-section">
                <h2 class="section-title">‚úÖ Settled Positions</h2>
                <div class="positions-grid">
                  <div 
                    v-for="position in settledPositions" 
                    :key="position.market_id"
                    class="position-card settled"
                  >
                    <h3>{{ position.game }}</h3>
                    <div class="position-details">
                      <div v-if="position.home_shares > 0" class="shares-info">
                        <span class="label">Home Shares:</span>
                        <span class="value">{{ position.home_shares.toFixed(2) }}</span>
                      </div>
                      <div v-if="position.away_shares > 0" class="shares-info">
                        <span class="label">Away Shares:</span>
                        <span class="value">{{ position.away_shares.toFixed(2) }}</span>
                      </div>
                      <div class="shares-info highlight">
                        <span class="label">Payout:</span>
                        <span class="value">{{ formatTokens(position.potential_payout) }}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Trade Modal -->
          <div v-if="showTradeModal" class="modal-overlay" @click="closeTradeModal">
            <div class="modal" @click.stop>
              <div class="modal-header">
                <h2>Place Prediction</h2>
                <button class="close-btn" @click="closeTradeModal">√ó</button>
              </div>
              
              <div class="modal-body">
                <div class="market-summary">
                  <h3>{{ selectedMarket.home_team }} vs {{ selectedMarket.away_team }}</h3>
                  <p class="game-time">{{ selectedMarket.game_date }} at {{ selectedMarket.game_time }}</p>
                </div>

                <div class="trade-form">
                  <div class="form-group">
                    <label>Predict Winner</label>
                    <div class="outcome-selector">
                      <button 
                        :class="['outcome-option', { active: tradeOutcome === 'home' }]"
                        @click="tradeOutcome = 'home'"
                      >
                        <div class="team">{{ selectedMarket.home_team }}</div>
                        <div class="elo-badge" v-if="selectedMarket.home_elo != null">Elo {{ selectedMarket.home_elo }}</div>
                        <div class="price">{{ selectedMarket.home_price.toFixed(1) }}¬¢</div>
                      </button>
                      <button 
                        :class="['outcome-option', { active: tradeOutcome === 'away' }]"
                        @click="tradeOutcome = 'away'"
                      >
                        <div class="team">{{ selectedMarket.away_team }}</div>
                        <div class="elo-badge" v-if="selectedMarket.away_elo != null">Elo {{ selectedMarket.away_elo }}</div>
                        <div class="price">{{ selectedMarket.away_price.toFixed(1) }}¬¢</div>
                      </button>
                    </div>
                  </div>

                  <div class="form-group">
                    <label>Amount (tokens)</label>
                    <input 
                      type="number" 
                      v-model.number="tradeAmount"
                      min="1"
                      :max="userBalance"
                      step="10"
                      class="amount-input"
                    >
                    <div class="quick-amounts">
                      <button @click="tradeAmount = 100" class="quick-btn">100</button>
                      <button @click="tradeAmount = 500" class="quick-btn">500</button>
                      <button @click="tradeAmount = 1000" class="quick-btn">1000</button>
                      <button @click="tradeAmount = userBalance" class="quick-btn">Max</button>
                    </div>
                  </div>

                  <div class="trade-summary">
                    <p>You'll receive approximately <strong>{{ (tradeAmount / (tradeOutcome === 'home' ? selectedMarket.home_price : selectedMarket.away_price) * 100).toFixed(2) }}</strong> shares</p>
                    <p class="potential">Potential return: <strong>{{ formatTokens(tradeAmount / (tradeOutcome === 'home' ? selectedMarket.home_price : selectedMarket.away_price) * 100) }}</strong></p>
                  </div>

                  <div v-if="tradeResult" :class="['trade-result', tradeResult.success ? 'success' : 'error']">
                    {{ tradeResult.message }}
                  </div>

                  <button 
                    class="submit-btn" 
                    @click="executeTrade"
                    :disabled="tradeProcessing || tradeAmount <= 0 || tradeAmount > userBalance"
                  >
                    <span v-if="tradeProcessing">Processing...</span>
                    <span v-else>Confirm Prediction</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Sell Modal -->
          <div v-if="showSellModal" class="modal-overlay" @click="closeSellModal">
            <div class="modal" @click.stop>
              <div class="modal-header">
                <h2>Sell Shares</h2>
                <button class="close-btn" @click="closeSellModal">√ó</button>
              </div>
              <div class="modal-body" v-if="sellPosition && sellMarket">
                <div class="market-summary">
                  <h3>{{ sellMarket.home_team }} vs {{ sellMarket.away_team }}</h3>
                  <p class="game-time">Selling: <strong>{{ sellOutcome === 'home' ? sellMarket.home_team : sellMarket.away_team }}</strong> shares</p>
                </div>
                <div class="trade-form">
                  <div class="form-group">
                    <label>Shares to Sell</label>
                    <input
                      type="number"
                      v-model.number="sellShares"
                      min="0.0001"
                      :max="sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares"
                      step="0.01"
                      class="amount-input"
                      @input="updateSellPreview"
                    >
                    <div class="quick-amounts">
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.25).toFixed(4)); updateSellPreview()" class="quick-btn">25%</button>
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.5).toFixed(4)); updateSellPreview()" class="quick-btn">50%</button>
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.75).toFixed(4)); updateSellPreview()" class="quick-btn">75%</button>
                      <button @click="sellShares = parseFloat((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares).toFixed(4)); updateSellPreview()" class="quick-btn">All</button>
                    </div>
                  </div>
                  <div class="trade-summary" v-if="sellPreview !== null">
                    <p>You will receive approximately <strong>{{ sellPreview.toFixed(2) }} ü™ô</strong></p>
                    <p class="potential" style="color:#e55; font-size:0.85rem;">LMSR sell-back ‚Äî no arbitrage. Actual payout may vary slightly.</p>
                  </div>
                  <div v-if="sellResult" :class="['trade-result', sellResult.success ? 'success' : 'error']">
                    {{ sellResult.message }}
                  </div>
                  <button
                    class="submit-btn"
                    @click="executeSell"
                    :disabled="sellProcessing || sellShares <= 0"
                  >
                    <span v-if="sellProcessing">Processing...</span>
                    <span v-else>Confirm Sell</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Price Chart Modal -->
          <div v-if="showPriceChart" class="modal-overlay" @click="closePriceChart">
            <div class="modal chart-modal" @click.stop>
              <div class="modal-header">
                <h2>üìà Price History</h2>
                <button class="close-btn" @click="closePriceChart">√ó</button>
              </div>
              <div class="modal-body">
                <div class="market-summary" v-if="selectedMarket">
                  <h3>{{ selectedMarket.home_team }} vs {{ selectedMarket.away_team }}</h3>
                  <p class="game-time">{{ selectedMarket.game_date }} at {{ selectedMarket.game_time }}</p>
                </div>
                <div class="chart-view-btns">
                  <button :class="['chart-view-btn', { active: chartView === '1h' }]" @click="setChartView('1h')">1H</button>
                  <button :class="['chart-view-btn', { active: chartView === '1d' }]" @click="setChartView('1d')">1D</button>
                  <button :class="['chart-view-btn', { active: chartView === '1w' }]" @click="setChartView('1w')">1W</button>
                </div>
                <div v-show="priceChartData === null" class="chart-loading">Loading history...</div>
                <div v-show="priceChartData !== null && priceChartData.length === 0" class="chart-loading">Could not load price history.</div>
                <div v-show="priceChartData !== null && priceChartData.length > 0" class="chart-container">
                  <canvas ref="priceChartCanvasRef"></canvas>
                </div>
              </div>
            </div>
          </div>

          <!-- Auth Modal -->
          <div v-if="showAuthModal" class="modal-overlay" @click="showAuthModal = false">
            <div class="modal auth-modal" @click.stop>
              <div class="modal-header">
                <h2>{{ authMode === 'login' ? 'Login' : 'Register' }}</h2>
                <button class="close-btn" @click="showAuthModal = false">√ó</button>
              </div>
              
              <div class="modal-body">
                <div class="auth-form">
                  <div class="form-group">
                    <label>Username</label>
                    <input 
                      type="text" 
                      v-model="authUsername"
                      placeholder="Enter username"
                      class="form-input"
                      @keyup.enter="authMode === 'login' ? login() : register()"
                    >
                  </div>

                  <div v-if="authMode === 'register'" class="form-group">
                    <label>Email</label>
                    <input 
                      type="email" 
                      v-model="authEmail"
                      placeholder="Enter email"
                      class="form-input"
                      @keyup.enter="register()"
                    >
                  </div>

                  <div class="form-group">
                    <label>Password</label>
                    <input 
                      type="password" 
                      v-model="authPassword"
                      placeholder="Enter password"
                      class="form-input"
                      @keyup.enter="authMode === 'login' ? login() : register()"
                    >
                  </div>

                  <div v-if="authError" class="auth-error">
                    {{ authError }}
                  </div>

                  <button 
                    class="submit-btn" 
                    @click="authMode === 'login' ? login() : register()"
                    :disabled="authProcessing || !authUsername || !authPassword || (authMode === 'register' && !authEmail)"
                  >
                    <span v-if="authProcessing">Processing...</span>
                    <span v-else>{{ authMode === 'login' ? 'Login' : 'Create Account' }}</span>
                  </button>

                  <div class="auth-switch">
                    <a href="#" @click.prevent="authMode = authMode === 'login' ? 'register' : 'login'">
                      {{ authMode === 'login' ? 'Need an account? Register' : 'Already have an account? Login' }}
                    </a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `
    }).mount('#app');
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      background: white;
      border-radius: 16px;
      padding: 24px 32px;
      margin-bottom: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
    }

    .branding h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
    }

    .subtitle {
      color: #666;
      font-size: 1rem;
    }

    .wallet {
      display: flex;
      gap: 32px;
      align-items: center;
    }

    .user-info {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    .username {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .auth-buttons {
      display: flex;
      gap: 12px;
    }

    .btn-login, .btn-register, .btn-logout {
      padding: 10px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-login {
      background: white;
      color: #667eea;
      border: 2px solid #667eea;
    }

    .btn-login:hover {
      background: #667eea;
      color: white;
    }

    .btn-register {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-register:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .btn-logout {
      background: #ff4444;
      color: white;
      font-size: 0.9rem;
      padding: 6px 16px;
    }

    .btn-logout:hover {
      background: #cc0000;
    }

    .balance, .total-value {
      text-align: right;
    }

    .label {
      display: block;
      font-size: 0.875rem;
      color: #666;
      margin-bottom: 4px;
    }

    .amount {
      display: block;
      font-size: 1.75rem;
      font-weight: 700;
      color: #333;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
    }

    .tab {
      flex: 1;
      padding: 16px;
      background: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .tab.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* Loading & Error */
    .loading, .error, .no-markets, .no-positions {
      background: white;
      padding: 60px 40px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Date Filter Bar (Top) */
    .date-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 24px;
      padding: 20px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      overflow-x: auto;
    }

    .date-chip {
      padding: 10px 20px;
      background: #f5f5f5;
      border: 2px solid transparent;
      border-radius: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      white-space: nowrap;
      font-size: 0.9rem;
    }

    .date-chip:hover {
      background: #e8e8e8;
      border-color: #667eea;
    }

    .date-chip.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    /* Markets Container Layout */
    .markets-container {
      display: flex;
      gap: 24px;
      align-items: flex-start;
    }

    .markets-content {
      flex: 1;
    }

    /* Sport Sidebar (Left) */
    .sport-sidebar {
      width: 200px;
      background: white;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      position: sticky;
      top: 20px;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }

    .sidebar-title {
      font-size: 1rem;
      margin-bottom: 16px;
      color: #333;
      font-weight: 700;
    }

    .sport-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sport-btn {
      padding: 10px 16px;
      background: #f5f5f5;
      border: 2px solid transparent;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-align: left;
      font-size: 0.9rem;
    }

    .sport-btn:hover {
      background: #e8e8e8;
      border-color: #667eea;
    }

    .sport-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    /* Market Section */
    .market-section {
      margin-bottom: 40px;
    }

    .section-title {
      font-size: 1.5rem;
      margin-bottom: 16px;
      color: white;
    }

    .markets-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 20px;
    }

    .market-card {
      background: white;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transition: all 0.3s;
    }

    .market-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }

    .market-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .sport-badge {
      padding: 6px 12px;
      background: #f0f0f0;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      color: #666;
    }

    .status-badge {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
    }

    .status-open {
      background: #d4edda;
      color: #155724;
    }

    .status-closed {
      background: #f8d7da;
      color: #721c24;
    }

    .status-settled {
      background: #d1ecf1;
      color: #0c5460;
    }

    .matchup h3 {
      font-size: 1.25rem;
      margin-bottom: 8px;
      color: #333;
    }

    .game-info {
      display: flex;
      gap: 16px;
      font-size: 0.875rem;
      color: #666;
      margin-bottom: 16px;
    }

    .odds-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .odds-section.disabled {
      opacity: 0.6;
    }

    .outcome-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      transition: all 0.3s;
    }

    .outcome-card.home {
      border: 2px solid #667eea;
    }

    .outcome-card.away {
      border: 2px solid #764ba2;
    }

    .team-name {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 4px;
      color: #333;
    }

    .elo-badge {
      font-size: 0.72rem;
      font-weight: 600;
      color: #764ba2;
      background: rgba(118, 75, 162, 0.1);
      border-radius: 4px;
      padding: 2px 6px;
      margin-bottom: 8px;
      display: inline-block;
    }

    .price {
      font-size: 1.75rem;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 12px;
    }

    .buy-btn {
      width: 100%;
      padding: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .buy-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .market-stats {
      font-size: 0.875rem;
      color: #666;
      padding-top: 12px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .settlement-info {
      margin-top: 16px;
    }

    .winner-banner {
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      font-weight: 700;
      font-size: 1.1rem;
    }

    .winner-banner.home {
      background: linear-gradient(135deg, #667eea20, #667eea40);
      color: #667eea;
    }

    .winner-banner.away {
      background: linear-gradient(135deg, #764ba220, #764ba240);
      color: #764ba2;
    }

    .trophy {
      font-size: 1.5rem;
      margin-right: 8px;
    }

    .final-score {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 12px;
      font-size: 1.8rem;
      font-weight: 700;
    }

    .final-score .score {
      padding: 8px 16px;
      border-radius: 8px;
      background: #f0f0f0;
    }

    .final-score .score.winner {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
    }

    .final-score .score.loser {
      background: #e9ecef;
      color: #6c757d;
    }

    .final-score .score-separator {
      color: #999;
    }

    /* Portfolio */
    .portfolio-container {
      background: white;
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .positions-section {
      margin-bottom: 40px;
    }

    .positions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 20px;
    }

    .position-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      border-left: 4px solid #667eea;
    }

    .position-card.settled {
      border-left-color: #28a745;
    }

    .position-card h3 {
      font-size: 1.1rem;
      margin-bottom: 16px;
      color: #333;
    }

    .position-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .shares-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.95rem;
    }

    .shares-info.highlight {
      font-weight: 700;
      font-size: 1.05rem;
      color: #667eea;
    }

    .sell-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .sell-btn {
      flex: 1;
      padding: 8px 14px;
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
    }

    .sell-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(234,88,12,0.35);
    }

    .chart-btn {
      background: none;
      border: 1px solid #667eea;
      color: #667eea;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .chart-btn:hover {
      background: #667eea;
      color: white;
    }

    .chart-modal {
      max-width: 700px !important;
    }

    .chart-container {
      height: 320px;
      position: relative;
    }

    .chart-loading {
      text-align: center;
      color: #888;
      padding: 40px 0;
      font-size: 1rem;
    }

    .chart-view-btns {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-bottom: 10px;
    }

    .chart-view-btn {
      padding: 4px 14px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      background: white;
      color: #555;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }

    .chart-view-btn:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .chart-view-btn.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal {
      background: white;
      border-radius: 16px;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px;
      border-bottom: 1px solid #e0e0e0;
    }

    .modal-header h2 {
      font-size: 1.5rem;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 2rem;
      cursor: pointer;
      color: #666;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .close-btn:hover {
      background: #f0f0f0;
    }

    .modal-body {
      padding: 24px;
    }

    .market-summary {
      text-align: center;
      margin-bottom: 24px;
      padding-bottom: 24px;
      border-bottom: 1px solid #e0e0e0;
    }

    .market-summary h3 {
      font-size: 1.25rem;
      margin-bottom: 8px;
      color: #333;
    }

    .game-time {
      color: #666;
      font-size: 0.95rem;
    }

    .trade-form {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 12px;
      color: #333;
    }

    .outcome-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .outcome-option {
      padding: 20px;
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }

    .outcome-option:hover {
      border-color: #667eea;
    }

    .outcome-option.active {
      border-color: #667eea;
      background: linear-gradient(135deg, #667eea10, #764ba210);
    }

    .outcome-option .team {
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }

    .outcome-option .price {
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
    }

    .amount-input {
      width: 100%;
      padding: 16px;
      font-size: 1.25rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      transition: all 0.3s;
    }

    .amount-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .quick-amounts {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .quick-btn {
      flex: 1;
      padding: 10px;
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .quick-btn:hover {
      background: #667eea;
      color: white;
    }

    .trade-summary {
      padding: 16px;
      background: #f8f9fa;
      border-radius: 12px;
      text-align: center;
    }

    .trade-summary p {
      margin-bottom: 8px;
      color: #666;
    }

    .trade-summary .potential {
      font-size: 1.1rem;
      color: #28a745;
    }

    .trade-result {
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      font-weight: 600;
    }

    .trade-result.success {
      background: #d4edda;
      color: #155724;
    }

    .trade-result.error {
      background: #f8d7da;
      color: #721c24;
    }

    .submit-btn {
      width: 100%;
      padding: 18px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
    }

    .submit-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
    }

    .submit-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Auth Modal */
    .auth-modal {
      max-width: 400px;
    }

    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .form-input {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.3s;
    }

    .form-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .auth-error {
      padding: 12px;
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 8px;
      color: #c00;
      font-size: 0.9rem;
    }

    .auth-switch {
      text-align: center;
      padding-top: 12px;
    }

    .auth-switch a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
    }

    .auth-switch a:hover {
      text-decoration: underline;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .header-content {
        flex-direction: column;
        text-align: center;
      }

      .wallet {
        width: 100%;
        justify-content: space-around;
      }

      .branding h1 {
        font-size: 2rem;
      }

      .date-filter-bar {
        padding: 15px;
      }

      .date-chip {
        font-size: 0.85rem;
        padding: 8px 16px;
      }

      .markets-container {
        flex-direction: column;
      }

      .sport-sidebar {
        width: 100%;
        position: static;
        max-height: none;
      }

      .sport-list {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .markets-grid, .positions-grid {
        grid-template-columns: 1fr;
      }

      .tabs {
        flex-direction: column;
      }
    }
  </style>
</body>
</html>
