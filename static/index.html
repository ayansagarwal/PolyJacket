<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PolyJacket - GT IM Prediction Market</title>
</head>
<body>
  <div id="app"></div>
  
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

  <script>
    // Custom Chart.js interaction mode: show tooltip at any x hover position
    // for stepped lines (finds last known value at cursor position).
    Chart.Interaction.modes.steppedHover = function(chart, e, options) {
      const mouseX = e.x;
      const items = [];
      chart.data.datasets.forEach(function(dataset, datasetIndex) {
        const meta = chart.getDatasetMeta(datasetIndex);
        if (!meta.visible) return;
        const pts = meta.data;
        // Walk forward; keep the last index whose pixel x <= cursor x
        let found = -1;
        for (let i = 0; i < pts.length; i++) {
          if (pts[i].x <= mouseX) found = i;
          else break;
        }
        if (found >= 0) {
          items.push({ datasetIndex: datasetIndex, index: found, element: pts[found] });
        }
      });
      return items;
    };
  </script>
  
  <script type="module">
    const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;
    
    createApp({
      setup() {
        // Authentication State
        const isLoggedIn = ref(false);
        const user = ref(null);
        const token = ref(null);
        const showAuthModal = ref(false);
        const authMode = ref('login'); // 'login' or 'register'
        const authUsername = ref('');
        const authEmail = ref('');
        const authPassword = ref('');
        const authError = ref('');
        const authProcessing = ref(false);
        
        // State
        const loading = ref(true);
        const error = ref(null);
        const markets = ref([]);
        const portfolio = ref(null);
        const userBalance = ref(0);
        const selectedSport = ref('All');
        const selectedDate = ref('All');
        const activeTab = ref('markets'); // 'markets', 'portfolio', or 'raffle'

        // Raffle state
        const raffleData = ref(null);
        const raffleBuying = ref(false);
        const raffleError = ref(null);
        const raffleSuccess = ref(null);
        const userRaffleTokens = ref(0);

        // Admin state
        const isAdmin = computed(() => isLoggedIn.value && user.value?.username === 'superuser');
        const adminRaffleWinners = ref([]);
        const adminRaffleLastWinner = ref(null);
        const adminRaffleRunning = ref(false);
        const adminRaffleClosing = ref(false);
        const adminRaffleError = ref(null);
        const adminSettleMarketId = ref('');
        const adminSettleHomeScore = ref('');
        const adminSettleAwayScore = ref('');
        const adminSettleResult = ref(null);
        const adminSettleError = ref(null);
        const adminSettleProcessing = ref(false);
        const adminAllMarkets = ref([]);
        const showTradeModal = ref(false);
        const selectedMarket = ref(null);
        const tradeOutcome = ref('home');
        const tradeAmount = ref(100);
        const tradeProcessing = ref(false);
        const tradeResult = ref(null);

        // Sell state
        const showSellModal = ref(false);
        const sellPosition = ref(null);   // position being sold
        const sellMarket = ref(null);     // corresponding market object
        const sellOutcome = ref('home');  // 'home' or 'away'
        const sellShares = ref(0);
        const sellProcessing = ref(false);
        const sellResult = ref(null);
        const sellPreview = ref(null);    // estimated tokens to receive

        // Price chart state
        const showPriceChart = ref(false);
        const priceChartData = ref(null);
        const priceChartInstance = ref(null);
        const priceChartCanvasRef = ref(null); // Vue template ref â€” always current DOM element
        const chartRawHistory = ref([]);  // full history, unfiltered
        const chartView = ref('1w');      // '1h', '1d', '1w'

        // Expanded game view state
        const showExpandedView = ref(false);
        const expandedMarket = ref(null);
        const expandedChartInstance = ref(null);
        const expandedChartCanvasRef = ref(null);
        const expandedChartView = ref('1w');
        const expandedChartKey = ref(0); // incrementing forces Vue to replace the canvas DOM node entirely
        const expandedChartHistory = ref([]);
        let expandedChartRenderSeq = 0; // incremented on every render request; stale renders self-abort
        
        // Chat state
        const chatMessages = ref([]);
        const chatMessage = ref('');
        const chatLoading = ref(false);
        const chatError = ref(null);
        // Score report state
        const showScoreReport = ref(false);
        const scoreReportHome = ref('');
        const scoreReportAway = ref('');
        const scoreReportLoading = ref(false);

        // Computed
        const uniqueSports = computed(() => {
          const sports = new Set(markets.value.map(m => m.sport));
          return Array.from(sports).sort();
        });

        const uniqueDates = computed(() => {
          const dates = new Set(markets.value.map(m => m.game_date).filter(d => d));
          return Array.from(dates).sort();
        });

        // Parse a market's date + time into a sortable timestamp
        function gameDateTime(m) {
          try {
            const [mo, da, yr] = (m.game_date || '').split('/');
            const t = m.game_time || '';
            if (!t || t === 'TBD') return new Date(yr, mo - 1, da, 23, 59, 0).getTime();
            if (t === 'FINAL' || t === 'BYE' || t === 'FORFEIT') return new Date(yr, mo - 1, da, 23, 59, 59).getTime();
            return new Date(`${m.game_date} ${t}`).getTime();
          } catch { return Infinity; }
        }

        const filteredMarkets = computed(() => {
          let filtered = markets.value;
          
          // Filter by sport
          if (selectedSport.value !== 'All') {
            filtered = filtered.filter(m => m.sport === selectedSport.value);
          }
          
          // Filter by date
          if (selectedDate.value !== 'All') {
            filtered = filtered.filter(m => m.game_date === selectedDate.value);
          }

          // Sort: open first, then closed, then settled; soonest game first within each group
          const statusOrder = { open: 0, closed: 1, settled: 2 };
          filtered = [...filtered].sort((a, b) => {
            const sd = (statusOrder[a.status] ?? 1) - (statusOrder[b.status] ?? 1);
            if (sd !== 0) return sd;
            return gameDateTime(a) - gameDateTime(b);
          });
          
          return filtered;
        });

        const openMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'open')
        );

        const closedMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'closed')
        );

        const settledMarkets = computed(() => 
          filteredMarkets.value.filter(m => m.status === 'settled')
        );

        // Removed totalValue - now just showing balance

        const openPositions = computed(() => {
          if (!portfolio.value) return [];
          return portfolio.value.open_positions || [];
        });

        const settledPositions = computed(() => {
          if (!portfolio.value) return [];
          return portfolio.value.settled_positions || [];
        });

        // Get user's position for the expanded market
        const expandedMarketPosition = computed(() => {
          if (!expandedMarket.value || !portfolio.value) return null;
          const allPositions = [...(portfolio.value.open_positions || []), ...(portfolio.value.settled_positions || [])];
          return allPositions.find(p => p.market_id === expandedMarket.value.market_id) || null;
        });

        // Helper to get today's date in the same format as game dates
        function getTodayDate() {
          const today = new Date();
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const month = months[today.getMonth()];
          const day = today.getDate();
          const year = today.getFullYear();
          return `${month} ${day}, ${year}`;
        }

        // Authentication Methods
        function checkAuth() {
          const savedToken = localStorage.getItem('auth_token');
          const savedUser = localStorage.getItem('user');
          if (savedToken && savedUser) {
            token.value = savedToken;
            user.value = JSON.parse(savedUser);
            isLoggedIn.value = true;
          }
        }

        async function login() {
          try {
            authProcessing.value = true;
            authError.value = '';
            const response = await fetch('/api/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                username: authUsername.value,
                password: authPassword.value
              })
            });
            
            if (!response.ok) {
              const data = await response.json();
              throw new Error(data.detail || 'Login failed');
            }
            
            const data = await response.json();
            token.value = data.access_token;
            user.value = { username: data.username, user_id: data.user_id };
            isLoggedIn.value = true;
            
            localStorage.setItem('auth_token', data.access_token);
            localStorage.setItem('user', JSON.stringify(user.value));
            
            showAuthModal.value = false;
            authUsername.value = '';
            authPassword.value = '';
            
            await fetchUser();
            await fetchPortfolio();
            await fetchMarkets();
          } catch (err) {
            authError.value = err.message;
          } finally {
            authProcessing.value = false;
          }
        }

        async function register() {
          try {
            authProcessing.value = true;
            authError.value = '';
            const response = await fetch('/api/register', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                username: authUsername.value,
                email: authEmail.value,
                password: authPassword.value
              })
            });
            
            if (!response.ok) {
              const data = await response.json();
              throw new Error(data.detail || 'Registration failed');
            }
            
            const data = await response.json();
            token.value = data.access_token;
            user.value = { username: data.username, user_id: data.user_id };
            isLoggedIn.value = true;
            
            localStorage.setItem('auth_token', data.access_token);
            localStorage.setItem('user', JSON.stringify(user.value));
            
            showAuthModal.value = false;
            authUsername.value = '';
            authEmail.value = '';
            authPassword.value = '';
            
            await fetchUser();
            await fetchPortfolio();
            await fetchMarkets();
          } catch (err) {
            authError.value = err.message;
          } finally {
            authProcessing.value = false;
          }
        }

        function logout() {
          token.value = null;
          user.value = null;
          isLoggedIn.value = false;
          localStorage.removeItem('auth_token');
          localStorage.removeItem('user');
          portfolio.value = null;
          userBalance.value = 0;
        }

        function openAuthModal(mode = 'login') {
          authMode.value = mode;
          authError.value = '';
          showAuthModal.value = true;
        }

        // Methods
        async function fetchMarkets() {
          try {
            loading.value = true;
            error.value = null;
            const response = await fetch('/api/markets');
            const data = await response.json();
            if (data.success) {
              markets.value = data.markets;
              // Sort by status: open first, then closed, then settled
              markets.value.sort((a, b) => {
                const statusOrder = { 'open': 0, 'closed': 1, 'settled': 2 };
                return statusOrder[a.status] - statusOrder[b.status];
              });
              
              // Auto-select today's date if available
              const todayDate = getTodayDate();
              const dates = new Set(markets.value.map(m => m.game_date).filter(d => d));
              if (dates.has(todayDate) && selectedDate.value === 'All') {
                selectedDate.value = todayDate;
              }
            } else {
              error.value = 'Failed to load markets';
            }
          } catch (err) {
            error.value = 'Error connecting to server';
            console.error(err);
          } finally {
            loading.value = false;
          }
        }

        async function fetchUser() {
          if (!token.value) return;
          try {
            const response = await fetch('/api/user', {
              headers: {
                'Authorization': `Bearer ${token.value}`
              }
            });
            if (response.ok) {
              const data = await response.json();
              userBalance.value = data.balance;
              user.value = {
                ...user.value,
                email: data.email,
                balance: data.balance
              };
              if (data.raffle_tokens != null) userRaffleTokens.value = data.raffle_tokens;
            }
          } catch (err) {
            console.error('Error fetching user:', err);
          }
        }

        async function fetchPortfolio() {
          if (!token.value) return;
          try {
            const response = await fetch('/api/portfolio', {
              headers: {
                'Authorization': `Bearer ${token.value}`
              }
            });
            if (response.ok) {
              const data = await response.json();
              portfolio.value = data;
              userBalance.value = data.balance;
            }
          } catch (err) {
            console.error('Error fetching portfolio:', err);
          }
        }

        // ---- Sell functionality ----
        function openSellModal(position, outcome) {
          const market = markets.value.find(m => m.market_id === position.market_id);
          if (!market) return;
          sellPosition.value = position;
          sellMarket.value = market;
          sellOutcome.value = outcome;
          const maxShares = outcome === 'home' ? position.home_shares : position.away_shares;
          sellShares.value = parseFloat(maxShares.toFixed(4));
          sellResult.value = null;
          updateSellPreview();
          showSellModal.value = true;
        }

        function closeSellModal() {
          showSellModal.value = false;
          sellPosition.value = null;
          sellMarket.value = null;
          sellResult.value = null;
          sellPreview.value = null;
        }

        function updateSellPreview() {
          if (!sellMarket.value || !sellShares.value || sellShares.value <= 0) {
            sellPreview.value = null;
            return;
          }
          // LMSR sell-back: before - after of cost function (mirrors backend)
          const b = 100;
          const shares = parseFloat(sellShares.value);
          let currentSide, otherSide;
          if (sellOutcome.value === 'home') {
            currentSide = sellMarket.value.home_shares;
            otherSide   = sellMarket.value.away_shares;
          } else {
            currentSide = sellMarket.value.away_shares;
            otherSide   = sellMarket.value.home_shares;
          }
          const before = b * Math.log(Math.exp(currentSide / b) + Math.exp(otherSide / b));
          const after  = b * Math.log(Math.exp((currentSide - shares) / b) + Math.exp(otherSide / b));
          sellPreview.value = Math.max(0, before - after);
        }

        async function executeSell() {
          if (!token.value) return;
          try {
            sellProcessing.value = true;
            sellResult.value = null;
            const response = await fetch('/api/sell', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                market_id: sellPosition.value.market_id,
                outcome: sellOutcome.value,
                shares: parseFloat(sellShares.value)
              })
            });
            const data = await response.json();
            if (response.ok && data.success) {
              sellResult.value = { success: true, message: data.message };
              await fetchMarkets();
              await fetchPortfolio();
              setTimeout(() => {
                closeSellModal();
              }, 1800);
            } else {
              sellResult.value = { success: false, message: data.detail || 'Sell failed' };
            }
          } catch (err) {
            sellResult.value = { success: false, message: 'Error executing sell' };
          } finally {
            sellProcessing.value = false;
          }
        }

        // ---- Price chart ----

        // Parse SQLite UTC timestamp string â†’ local Date object
        function parseUTC(ts) {
          if (!ts) return new Date();
          // SQLite CURRENT_TIMESTAMP: "YYYY-MM-DD HH:MM:SS" â€” treat as UTC
          return new Date(ts.trim().replace(' ', 'T') + 'Z');
        }

        async function openPriceChart(market) {
          selectedMarket.value = market;
          showPriceChart.value = true;
          priceChartData.value = null;
          chartView.value = '1w';
          chartRawHistory.value = [];
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          try {
            const res = await fetch(`/api/markets/${market.market_id}/history`);
            const data = await res.json();
            if (data.success) {
              priceChartData.value = data.history;
              chartRawHistory.value = data.history;
              await nextTick();
              renderPriceChart(data.history, market);
            } else {
              priceChartData.value = [];
            }
          } catch (err) {
            console.error('Failed to load price history:', err);
            priceChartData.value = [];
          }
        }

        function closePriceChart() {
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          showPriceChart.value = false;
          priceChartData.value = null;
          chartRawHistory.value = [];
        }

        function setChartView(v) {
          chartView.value = v;
          if (priceChartInstance.value) {
            priceChartInstance.value.destroy();
            priceChartInstance.value = null;
          }
          // One rAF lets the browser flush the canvas clear that destroy() triggers,
          // so the new Chart() always gets a clean, uncorrupted 2D context.
          requestAnimationFrame(() => {
            renderPriceChart(chartRawHistory.value, selectedMarket.value);
          });
        }

        function renderPriceChart(history, market) {
          // Use Vue template ref so we always get the current live canvas element
          const canvas = priceChartCanvasRef.value;
          if (!canvas || !history.length) return;

          // Destroy any lingering instance on THIS canvas before creating a new one
          if (priceChartInstance.value) {
            try { priceChartInstance.value.destroy(); } catch (_) {}
            priceChartInstance.value = null;
          }

          // Build time-based data points, converting UTC â†’ local Date objects
          const points = history.map(h => ({
            x: parseUTC(h.timestamp),
            home: h.home_price,
            away: h.away_price
          }));

          // Determine x-axis window based on selected view
          const now = new Date();
          let xMin;
          if (chartView.value === '1h') {
            xMin = new Date(now.getTime() - 3600 * 1000);
          } else if (chartView.value === '1d') {
            xMin = new Date(now.getTime() - 86400 * 1000);
          } else {
            xMin = new Date(now.getTime() - 7 * 86400 * 1000);
          }

          // Split into points before and within the window
          const before = points.filter(p => p.x < xMin);
          const after  = points.filter(p => p.x >= xMin);

          // Left anchor: last known price before the window, placed exactly at xMin.
          // If no prior point exists, use the very first point's price (opening price).
          const leftSrc = before.length ? before[before.length - 1] : (points[0] || { home: 50, away: 50 });
          const leftAnchor = { x: new Date(xMin), home: leftSrc.home, away: leftSrc.away };

          // Right anchor: extend last known price to 'now' so the line fills the window.
          const rightSrc = after.length ? after[after.length - 1] : leftSrc;
          const rightAnchor = { x: new Date(now), home: rightSrc.home, away: rightSrc.away };

          // Combine: left anchor â†’ points within window â†’ right anchor
          // Deduplicate in case a point lands exactly on xMin or now
          const visiblePoints = [leftAnchor, ...after, rightAnchor];

          // Determine tick granularity for readability
          let timeUnit, tooltipFmt;
          if (chartView.value === '1h') {
            timeUnit = 'minute';
            tooltipFmt = 'h:mm a';
          } else if (chartView.value === '1d') {
            timeUnit = 'hour';
            tooltipFmt = 'h:mm a';
          } else {
            timeUnit = 'day';
            tooltipFmt = 'MMM d, h:mm a';
          }

          priceChartInstance.value = new Chart(canvas, {
            type: 'line',
            data: {
              datasets: [
                {
                  label: `${market.home_team}`,
                  data: visiblePoints.map(p => ({ x: p.x, y: p.home })),
                  borderColor: '#667eea',
                  backgroundColor: 'rgba(102,126,234,0.08)',
                  stepped: 'before',
                  tension: 0,
                  fill: true,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  pointHoverBackgroundColor: '#667eea',
                  borderWidth: 2,
                  yAxisID: 'yHome'
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'steppedHover', intersect: false, axis: 'x' },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    title: items => items[0] ? items[0].label : '',
                    label: ctx => {
                      const home = ctx.parsed.y;
                      const away = 100 - home;
                      return [
                        `${market.home_team}: ${home.toFixed(1)}Â¢`,
                        `${market.away_team}: ${away.toFixed(1)}Â¢`
                      ];
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: timeUnit,
                    tooltipFormat: tooltipFmt,
                    displayFormats: {
                      minute: 'h:mm a',
                      hour:   'h a',
                      day:    'MMM d'
                    }
                  },
                  min: xMin,
                  max: now,
                  ticks: { maxTicksLimit: 7, maxRotation: 20 },
                  grid: { color: 'rgba(0,0,0,0.04)' }
                },
                yHome: {
                  position: 'left',
                  min: 0,
                  max: 100,
                  ticks: { callback: v => v + 'Â¢' },
                  title: { display: true, text: `${market.home_team} â†’`, color: '#667eea', font: { weight: 'bold' } },
                  grid: { color: 'rgba(0,0,0,0.06)' }
                },
                yAway: {
                  position: 'right',
                  min: 0,
                  max: 100,
                  ticks: { callback: v => (100 - v) + 'Â¢' },
                  title: { display: true, text: `â† ${market.away_team}`, color: '#f97316', font: { weight: 'bold' } },
                  grid: { drawOnChartArea: false }
                }
              }
            }
          });
        }


        async function executeTrade() {
          if (!token.value) {
            openAuthModal('login');
            return;
          }
          
          try {
            tradeProcessing.value = true;
            tradeResult.value = null;
            
            const response = await fetch('/api/trade', {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                market_id: selectedMarket.value.market_id,
                outcome: tradeOutcome.value,
                amount: parseFloat(tradeAmount.value)
              })
            });

            const data = await response.json();
            
            if (response.ok && data.success) {
              tradeResult.value = {
                success: true,
                message: `Successfully purchased ${data.shares_purchased} shares at ${data.price_per_share.toFixed(2)} tokens per share!`,
                data: data
              };
              
              // Refresh data
              await fetchMarkets();
              await fetchPortfolio();
              
              // Reset form
              setTimeout(() => {
                showTradeModal.value = false;
                tradeResult.value = null;
                tradeAmount.value = 100;
              }, 2000);
            } else {
              tradeResult.value = {
                success: false,
                message: data.detail || 'Trade failed'
              };
            }
          } catch (err) {
            tradeResult.value = {
              success: false,
              message: 'Error executing trade'
            };
            console.error(err);
          } finally {
            tradeProcessing.value = false;
          }
        }

        function openTradeModal(market) {
          selectedMarket.value = market;
          showTradeModal.value = true;
          tradeOutcome.value = 'home';
          tradeAmount.value = 100;
          tradeResult.value = null;
        }

        function closeTradeModal() {
          showTradeModal.value = false;
          selectedMarket.value = null;
          tradeResult.value = null;
        }

        async function openExpandedView(market) {
          expandedChartRenderSeq = 0;
          expandedMarket.value = market;
          showExpandedView.value = true;
          chatMessages.value = [];
          chatMessage.value = '';
          chatError.value = null;
          
          // Load chat messages
          await loadChatMessages(market.market_id);
          
          // Load price history for the chart
          await loadExpandedChart(market);
        }

        function closeExpandedView() {
          expandedChartRenderSeq = 0;
          showExpandedView.value = false;
          expandedMarket.value = null;
          if (expandedChartInstance.value) {
            expandedChartInstance.value.destroy();
            expandedChartInstance.value = null;
          }
        }

        async function fetchRaffleData() {
          try {
            const headers = token.value ? { 'Authorization': `Bearer ${token.value}` } : {};
            const response = await fetch('/api/raffle', { headers });
            if (response.ok) {
              const data = await response.json();
              raffleData.value = data;
              if (data.user_raffle_tokens != null) userRaffleTokens.value = data.user_raffle_tokens;
            }
          } catch (err) {
            console.error('Error fetching raffle:', err);
          }
        }

        async function buyRaffleTickets(tierId) {
          if (!isLoggedIn.value) {
            raffleError.value = 'Please log in to buy raffle tickets';
            return;
          }
          raffleBuying.value = tierId;
          raffleError.value = null;
          raffleSuccess.value = null;
          try {
            const response = await fetch('/api/raffle/buy', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({ tier_id: tierId })
            });
            const data = await response.json();
            if (data.success) {
              raffleSuccess.value = data.message;
              raffleData.value = { ...raffleData.value, total_tickets: data.total_tickets, user_tickets: data.user_tickets };
              userRaffleTokens.value = data.new_raffle_tokens;
            } else {
              raffleError.value = data.detail || 'Purchase failed';
            }
          } catch (err) {
            raffleError.value = 'Purchase failed';
          } finally {
            raffleBuying.value = false;
          }
        }

        // ===== ADMIN FUNCTIONS =====
        async function adminFetchMarkets() {
          try {
            const response = await fetch('/api/markets', { headers: { 'Authorization': `Bearer ${token.value}` } });
            const data = await response.json();
            adminAllMarkets.value = (data.markets || []).filter(m => m.status !== 'settled');
          } catch (e) { console.error('admin fetch markets', e); }
          // Also load raffle winners + closed state
          try {
            const r = await fetch('/api/admin/raffle/status', { headers: { 'Authorization': `Bearer ${token.value}` } });
            if (r.ok) {
              const d = await r.json();
              adminRaffleWinners.value = d.winners || [];
            }
          } catch (e) { /* ignore */ }
          fetchRaffleData();
        }

        async function adminRunRaffle() {
          adminRaffleRunning.value = true;
          adminRaffleError.value = null;
          adminRaffleLastWinner.value = null;
          try {
            const response = await fetch('/api/admin/raffle/run', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token.value}` }
            });
            const data = await response.json();
            if (response.ok) {
              adminRaffleLastWinner.value = data.winner;
              adminRaffleWinners.value = data.all_winners || [];
              fetchRaffleData();
            } else {
              adminRaffleError.value = data.detail || 'Failed to draw winner';
            }
          } catch (e) {
            adminRaffleError.value = 'Request failed';
          } finally {
            adminRaffleRunning.value = false;
          }
        }

        async function adminCloseRaffle() {
          if (!confirm('Close the raffle? Ticket purchases will be disabled.')) return;
          adminRaffleClosing.value = true;
          try {
            const response = await fetch('/api/admin/raffle/close', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token.value}` }
            });
            const data = await response.json();
            if (response.ok) { fetchRaffleData(); }
            else { adminRaffleError.value = data.detail || 'Failed to close raffle'; }
          } catch (e) { adminRaffleError.value = 'Request failed'; }
          finally { adminRaffleClosing.value = false; }
        }

        async function adminOpenRaffle() {
          adminRaffleClosing.value = true;
          try {
            const response = await fetch('/api/admin/raffle/open', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token.value}` }
            });
            const data = await response.json();
            if (response.ok) { fetchRaffleData(); }
            else { adminRaffleError.value = data.detail || 'Failed to reopen raffle'; }
          } catch (e) { adminRaffleError.value = 'Request failed'; }
          finally { adminRaffleClosing.value = false; }
        }

        async function adminSettleGame() {
          adminSettleError.value = null;
          adminSettleResult.value = null;
          if (!adminSettleMarketId.value) { adminSettleError.value = 'Select a market'; return; }
          const h = parseInt(adminSettleHomeScore.value);
          const a = parseInt(adminSettleAwayScore.value);
          if (isNaN(h) || isNaN(a)) { adminSettleError.value = 'Enter valid scores'; return; }
          adminSettleProcessing.value = true;
          try {
            const response = await fetch('/api/admin/settle-game', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token.value}` },
              body: JSON.stringify({ market_id: adminSettleMarketId.value, home_score: h, away_score: a })
            });
            const data = await response.json();
            if (response.ok) {
              adminSettleResult.value = data.message;
              adminSettleMarketId.value = '';
              adminSettleHomeScore.value = '';
              adminSettleAwayScore.value = '';
              fetchMarkets();
              adminFetchMarkets();
            } else {
              adminSettleError.value = data.detail || 'Settle failed';
            }
          } catch (e) {
            adminSettleError.value = 'Request failed';
          } finally {
            adminSettleProcessing.value = false;
          }
        }
        // ===========================

        async function loadChatMessages(marketId) {
          try {
            chatLoading.value = true;
            const response = await fetch(`/api/markets/${marketId}/chat`);
            const data = await response.json();
            if (data.success) {
              chatMessages.value = data.messages;
            }
          } catch (err) {
            console.error('Error loading chat:', err);
          } finally {
            chatLoading.value = false;
          }
        }

        async function sendChatMessage() {
          if (!chatMessage.value.trim()) return;
          if (!isLoggedIn.value) {
            chatError.value = 'Please log in to chat';
            return;
          }

          try {
            const response = await fetch(`/api/markets/${expandedMarket.value.market_id}/chat`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                market_id: expandedMarket.value.market_id,
                message: chatMessage.value
              })
            });

            const data = await response.json();
            if (data.success) {
              chatMessages.value.push(data.message);
              chatMessage.value = '';
              chatError.value = null;
              // Scroll to bottom of chat
              await nextTick();
              const chatContainer = document.querySelector('.chat-messages');
              if (chatContainer) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
              }
            } else {
              chatError.value = data.detail || 'Failed to send message';
            }
          } catch (err) {
            console.error('Error sending message:', err);
            chatError.value = 'Failed to send message';
          }
        }

        async function voteOnScoreReport(messageId, vote) {
          if (!isLoggedIn.value) return;
          try {
            const response = await fetch(`/api/markets/${expandedMarket.value.market_id}/score-report/${messageId}/vote`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({ vote })
            });
            const data = await response.json();
            if (data.success) {
              const idx = chatMessages.value.findIndex(m => m.message_id === messageId);
              if (idx !== -1) chatMessages.value[idx] = data.message;
            }
          } catch (err) {
            console.error('Error voting:', err);
          }
        }

        async function sendScoreReport() {
          if (!isLoggedIn.value) {
            chatError.value = 'Please log in to report a score';
            return;
          }
          if (scoreReportHome.value === '' || scoreReportAway.value === '') {
            chatError.value = 'Enter scores for both teams';
            return;
          }
          scoreReportLoading.value = true;
          try {
            const response = await fetch(`/api/markets/${expandedMarket.value.market_id}/score-report`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token.value}`
              },
              body: JSON.stringify({
                home_score: parseInt(scoreReportHome.value),
                away_score: parseInt(scoreReportAway.value)
              })
            });
            const data = await response.json();
            if (data.success) {
              chatMessages.value.push(data.message);
              scoreReportHome.value = '';
              scoreReportAway.value = '';
              showScoreReport.value = false;
              chatError.value = null;
              await nextTick();
              const chatContainer = document.querySelector('.chat-messages');
              if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
            } else {
              chatError.value = data.detail || 'Failed to report score';
            }
          } catch (err) {
            console.error('Error reporting score:', err);
            chatError.value = 'Failed to report score';
          } finally {
            scoreReportLoading.value = false;
          }
        }

        async function loadExpandedChart(market) {
          try {
            const response = await fetch(`/api/markets/${market.market_id}/history`);
            const data = await response.json();
            if (data.success) {
              expandedChartHistory.value = data.history;
              await nextTick();
              renderExpandedChart(market, data.history);
            }
          } catch (err) {
            console.error('Error loading chart:', err);
          }
        }

        function renderExpandedChart(market, history) {
          const canvas = expandedChartCanvasRef.value;
          if (!canvas) return;

          // Destroy any existing instance before creating a new one
          if (expandedChartInstance.value) {
            expandedChartInstance.value.destroy();
            expandedChartInstance.value = null;
          }

          const parseUTC = (isoStr) => new Date(isoStr + 'Z');
          const points = history.map(h => ({
            x: parseUTC(h.timestamp),
            home: h.home_price,
            away: h.away_price
          }));

          const now = new Date();
          let xMin;
          if (expandedChartView.value === '1h') {
            xMin = new Date(now.getTime() - 3600 * 1000);
          } else if (expandedChartView.value === '1d') {
            xMin = new Date(now.getTime() - 86400 * 1000);
          } else {
            xMin = new Date(now.getTime() - 7 * 86400 * 1000);
          }

          const before = points.filter(p => p.x < xMin);
          const after = points.filter(p => p.x >= xMin);

          const leftSrc = before.length ? before[before.length - 1] : (points[0] || { home: 50, away: 50 });
          const leftAnchor = { x: new Date(xMin), home: leftSrc.home, away: leftSrc.away };

          const rightSrc = after.length ? after[after.length - 1] : leftSrc;
          const rightAnchor = { x: new Date(now), home: rightSrc.home, away: rightSrc.away };

          const visiblePoints = [leftAnchor, ...after, rightAnchor];

          let timeUnit, tooltipFmt;
          if (expandedChartView.value === '1h') {
            timeUnit = 'minute';
            tooltipFmt = 'h:mm a';
          } else if (expandedChartView.value === '1d') {
            timeUnit = 'hour';
            tooltipFmt = 'h:mm a';
          } else {
            timeUnit = 'day';
            tooltipFmt = 'MMM d, h:mm a';
          }

          expandedChartInstance.value = new Chart(canvas, {
            type: 'line',
            data: {
              datasets: [
                {
                  label: `${market.home_team}`,
                  data: visiblePoints.map(p => ({ x: p.x, y: p.home })),
                  borderColor: '#667eea',
                  backgroundColor: 'rgba(102,126,234,0.08)',
                  stepped: 'before',
                  tension: 0,
                  fill: true,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  pointHoverBackgroundColor: '#667eea',
                  borderWidth: 2
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'steppedHover', intersect: false, axis: 'x' },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    title: items => items[0] ? items[0].label : '',
                    label: ctx => {
                      const home = ctx.parsed.y;
                      const away = 100 - home;
                      return [
                        `${market.home_team}: ${home.toFixed(1)}Â¢`,
                        `${market.away_team}: ${away.toFixed(1)}Â¢`
                      ];
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: timeUnit,
                    tooltipFormat: tooltipFmt,
                    displayFormats: {
                      minute: 'h:mm a',
                      hour: 'h a',
                      day: 'MMM d'
                    }
                  },
                  min: xMin,
                  max: now,
                  grid: { color: 'rgba(0,0,0,0.05)' }
                },
                y: {
                  min: 0,
                  max: 100,
                  ticks: {
                    callback: value => `${value}Â¢`
                  },
                  grid: { color: 'rgba(0,0,0,0.05)' }
                }
              }
            }
          });
        }

        async function changeExpandedChartView(view) {
          expandedChartView.value = view;
          if (!expandedMarket.value || expandedChartHistory.value.length === 0) return;

          // Claim this render slot; stale renders will self-abort
          const mySeq = ++expandedChartRenderSeq;

          // Destroy Chart.js instance before releasing the canvas
          if (expandedChartInstance.value) {
            expandedChartInstance.value.destroy();
            expandedChartInstance.value = null;
          }

          // Bump the key so Vue tears down the old <canvas> and mounts a fresh one
          expandedChartKey.value++;

          // Wait for Vue to finish DOM replacement
          await nextTick();

          // If another tab was clicked while we awaited, bail â€” the winner will render
          if (mySeq !== expandedChartRenderSeq) return;

          renderExpandedChart(expandedMarket.value, expandedChartHistory.value);
        }

        function getStatusColor(status) {
          return {
            'open': 'status-open',
            'closed': 'status-closed',
            'settled': 'status-settled'
          }[status] || '';
        }

        function getStatusIcon(status) {
          return {
            'open': 'ðŸŸ¢',
            'closed': 'ðŸ”´',
            'settled': 'âœ…'
          }[status] || '';
        }

        function getStatusText(status) {
          return {
            'open': 'Open',
            'closed': 'Closed',
            'settled': 'Settled'
          }[status] || status;
        }

        function formatTokens(amount) {
          return `${amount.toFixed(0)} ðŸª™`;
        }

        // Helper functions to handle trading from expanded view
        function buyFromExpandedView(outcome) {
          const market = expandedMarket.value;
          closeExpandedView();
          setTimeout(() => {
            openTradeModal(market);
            tradeOutcome.value = outcome;
          }, 100);
        }

        function sellFromExpandedView(outcome) {
          const position = expandedMarketPosition.value;
          closeExpandedView();
          setTimeout(() => {
            openSellModal(position, outcome);
          }, 100);
        }

        // Initialize
        onMounted(async () => {
          checkAuth();
          await fetchMarkets();
          if (isLoggedIn.value) {
            await fetchUser();
            await fetchPortfolio();
          }
        });

        return {
          // Auth
          isLoggedIn,
          user,
          showAuthModal,
          authMode,
          authUsername,
          authEmail,
          authPassword,
          authError,
          authProcessing,
          login,
          register,
          logout,
          openAuthModal,
          // State
          loading,
          error,
          markets,
          portfolio,
          userBalance,
          selectedSport,
          selectedDate,
          uniqueDates,
          activeTab,
          showTradeModal,
          selectedMarket,
          tradeOutcome,
          tradeAmount,
          tradeProcessing,
          tradeResult,
          uniqueSports,
          filteredMarkets,
          openMarkets,
          closedMarkets,
          settledMarkets,
          openPositions,
          settledPositions,
          // Methods
          fetchMarkets,
          fetchPortfolio,
          executeTrade,
          openTradeModal,
          closeTradeModal,
          getStatusColor,
          getStatusIcon,
          getStatusText,
          formatTokens,
          // Sell
          showSellModal,
          sellPosition,
          sellMarket,
          sellOutcome,
          sellShares,
          sellProcessing,
          sellResult,
          sellPreview,
          openSellModal,
          closeSellModal,
          updateSellPreview,
          executeSell,
          // Price chart
          showPriceChart,
          priceChartData,
          priceChartCanvasRef,
          chartView,
          openPriceChart,
          closePriceChart,
          setChartView,
          // Expanded game view
          showExpandedView,
          expandedMarket,
          expandedChartCanvasRef,
          expandedChartView,
          expandedChartKey,
          expandedMarketPosition,
          openExpandedView,
          closeExpandedView,
          changeExpandedChartView,
          buyFromExpandedView,
          sellFromExpandedView,
          // Chat
          chatMessages,
          chatMessage,
          chatLoading,
          chatError,
          sendChatMessage,
          // Raffle
          raffleData,
          raffleBuying,
          raffleError,
          raffleSuccess,
          userRaffleTokens,
          fetchRaffleData,
          buyRaffleTickets,
          // Score report
          showScoreReport,
          scoreReportHome,
          scoreReportAway,
          scoreReportLoading,
          sendScoreReport,
          voteOnScoreReport,
          // Admin
          isAdmin,
          adminRaffleWinners,
          adminRaffleLastWinner,
          adminRaffleRunning,
          adminRaffleClosing,
          adminRaffleError,
          adminSettleMarketId,
          adminSettleHomeScore,
          adminSettleAwayScore,
          adminSettleResult,
          adminSettleError,
          adminSettleProcessing,
          adminAllMarkets,
          adminRunRaffle,
          adminCloseRaffle,
          adminOpenRaffle,
          adminSettleGame,
          adminFetchMarkets
        };
      },
      
      template: `
        <div class="app-container">
          <header class="header">
            <div class="header-content">
              <div class="branding">
                <h1>âš¡ PolyJacket</h1>
                <p class="subtitle">GT Intramural Prediction Markets</p>
              </div>
              <div class="wallet">
                <div v-if="isLoggedIn" class="user-info">
                  <div class="balance">
                    <span class="label">Balance</span>
                    <span class="amount">{{ formatTokens(userBalance) }}</span>
                  </div>
                  <div class="username">
                    <span>ðŸ‘¤ {{ user.username }}</span>
                    <button class="btn-logout" @click="logout">Logout</button>
                  </div>
                </div>
                <div v-else class="auth-buttons">
                  <button class="btn-login" @click="openAuthModal('login')">Login</button>
                  <button class="btn-register" @click="openAuthModal('register')">Register</button>
                </div>
              </div>
            </div>
          </header>

          <!-- Navigation Tabs -->
          <div class="tabs">
            <button 
              :class="['tab', { active: activeTab === 'markets' }]"
              @click="activeTab = 'markets'"
            >
              ðŸ“Š Markets ({{ markets.length }})
            </button>
            <button 
              :class="['tab', { active: activeTab === 'portfolio' }]"
              @click="activeTab = 'portfolio'"
            >
              ðŸ’¼ Portfolio ({{ openPositions.length }})
            </button>
            <button 
              :class="['tab', { active: activeTab === 'raffle' }]"
              @click="activeTab = 'raffle'; fetchRaffleData()"
            >
              ðŸŽŸï¸ Raffle
            </button>
            <button
              v-if="isAdmin"
              :class="['tab', 'tab-admin', { active: activeTab === 'admin' }]"
              @click="activeTab = 'admin'; adminFetchMarkets()"
            >
              âš™ï¸ Admin
            </button>
          </div>

          <!-- Loading State -->
          <div v-if="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading markets...</p>
          </div>

          <!-- Error State -->
          <div v-else-if="error" class="error">
            <p>âŒ {{ error }}</p>
            <button @click="fetchMarkets" class="retry-btn">Retry</button>
          </div>

          <!-- Markets Tab -->
          <div v-else-if="activeTab === 'markets'" class="markets-tab">
            <!-- Date Filter (Top Bar) -->
            <div class="date-filter-bar">
              <button 
                :class="['date-chip', { active: selectedDate === 'All' }]"
                @click="selectedDate = 'All'"
              >
                All Dates
              </button>
              <button 
                v-for="date in uniqueDates" 
                :key="date"
                :class="['date-chip', { active: selectedDate === date }]"
                @click="selectedDate = date"
              >
                {{ date }}
              </button>
            </div>

            <!-- Markets Container -->
            <div class="markets-container">
              <!-- Sport Sidebar -->
              <div class="sport-sidebar">
                <h3 class="sidebar-title">ðŸ€ Filter by Sport</h3>
                <div class="sport-list">
                  <button 
                    :class="['sport-btn', { active: selectedSport === 'All' }]"
                    @click="selectedSport = 'All'"
                  >
                    All Sports
                  </button>
                  <button 
                    v-for="sport in uniqueSports" 
                    :key="sport"
                    :class="['sport-btn', { active: selectedSport === sport }]"
                    @click="selectedSport = sport"
                  >
                    {{ sport }}
                  </button>
                </div>
              </div>

              <!-- Markets Content -->
              <div class="markets-content">

            <!-- Open Markets -->
            <div v-if="openMarkets.length > 0" class="market-section">
              <h2 class="section-title">ðŸŸ¢ Open Markets</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in openMarkets" 
                  :key="market.market_id"
                  class="market-card open clickable"
                  @click="openExpandedView(market)"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-open">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div class="game-info">
                      <span>ðŸ“… {{ market.game_date }}</span>
                      <span>â° {{ market.game_time }}</span>
                    </div>
                  </div>

                  <div class="odds-section">
                    <div class="outcome-card home">
                      <div class="team-name">{{ market.home_team }}</div>
                      <div class="elo-badge" v-if="market.home_elo != null">Elo {{ market.home_elo }}</div>
                      <div class="price">{{ market.home_price.toFixed(1) }}Â¢</div>
                      <button 
                        class="buy-btn"
                        @click.stop="openTradeModal(market); tradeOutcome = 'home'"
                      >
                        Buy
                      </button>
                    </div>
                    
                    <div class="outcome-card away">
                      <div class="team-name">{{ market.away_team }}</div>
                      <div class="elo-badge" v-if="market.away_elo != null">Elo {{ market.away_elo }}</div>
                      <div class="price">{{ market.away_price.toFixed(1) }}Â¢</div>
                      <button 
                        class="buy-btn"
                        @click.stop="openTradeModal(market); tradeOutcome = 'away'"
                      >
                        Buy
                      </button>
                    </div>
                  </div>

                  <div class="market-stats">
                    <span>Volume: {{ formatTokens(market.total_volume) }}</span>
                    <span class="expand-hint">Click to view details ðŸ‘†</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Closed Markets -->
            <div v-if="closedMarkets.length > 0" class="market-section">
              <h2 class="section-title">ðŸ”´ Closed Markets (Awaiting Results)</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in closedMarkets" 
                  :key="market.market_id"
                  class="market-card closed clickable"
                  @click="openExpandedView(market)"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-closed">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div class="game-info">
                      <span>ðŸ“… {{ market.game_date }}</span>
                      <span>â° {{ market.game_time }}</span>
                    </div>
                  </div>

                  <div class="odds-section disabled">
                    <div class="outcome-card home">
                      <div class="team-name">{{ market.home_team }}</div>
                      <div class="elo-badge" v-if="market.home_elo != null">Elo {{ market.home_elo }}</div>
                      <div class="price">{{ market.home_price.toFixed(1) }}Â¢</div>
                    </div>
                    
                    <div class="outcome-card away">
                      <div class="team-name">{{ market.away_team }}</div>
                      <div class="elo-badge" v-if="market.away_elo != null">Elo {{ market.away_elo }}</div>
                      <div class="price">{{ market.away_price.toFixed(1) }}Â¢</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Settled Markets -->
            <div v-if="settledMarkets.length > 0" class="market-section">
              <h2 class="section-title">âœ… Settled Markets</h2>
              <div class="markets-grid">
                <div 
                  v-for="market in settledMarkets" 
                  :key="market.market_id"
                  class="market-card settled clickable"
                  @click="openExpandedView(market)"
                >
                  <div class="market-header">
                    <span class="sport-badge">{{ market.sport }}</span>
                    <span class="status-badge status-settled">{{ getStatusIcon(market.status) }} {{ getStatusText(market.status) }}</span>
                  </div>
                  
                  <div class="matchup">
                    <h3>{{ market.home_team }} vs {{ market.away_team }}</h3>
                    <div v-if="market.home_score && market.away_score && market.home_score !== '--' && market.away_score !== '--'" class="final-score">
                      <span :class="['score', market.winner === 'home' ? 'winner' : 'loser']">{{ market.home_score }}</span>
                      <span class="score-separator">-</span>
                      <span :class="['score', market.winner === 'away' ? 'winner' : 'loser']">{{ market.away_score }}</span>
                    </div>
                  </div>

                  <div class="settlement-info">
                    <template v-if="market.winner === 'push'">
                      <div class="winner-banner push">
                        <span class="trophy">â†©ï¸</span>
                        <span>Game Voided</span>
                      </div>
                    </template>
                    <template v-else>
                      <div :class="['winner-banner', market.winner === 'home' ? 'home' : 'away']">
                        <span class="trophy">ðŸ†</span>
                        <span>{{ market.winner === 'home' ? market.home_team : market.away_team }} Won</span>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <div v-if="filteredMarkets.length === 0" class="no-markets">
              <p>No markets available</p>
            </div>
            </div>
            <!-- End markets-content -->
            </div>
            <!-- End markets-container -->
          </div>
          <!-- End markets-tab -->

          <!-- Portfolio Tab -->
          <div v-else-if="activeTab === 'portfolio'" class="portfolio-container">
            <div v-if="openPositions.length === 0 && settledPositions.length === 0" class="no-positions">
              <h2>ðŸ“­ No Positions Yet</h2>
              <p>Visit the Markets tab to start predicting!</p>
            </div>

            <div v-else>
              <!-- Open Positions -->
              <div v-if="openPositions.length > 0" class="positions-section">
                <h2 class="section-title">ðŸ“Š Open Positions</h2>
                <div class="positions-grid">
                  <div 
                    v-for="position in openPositions" 
                    :key="position.market_id"
                    class="position-card"
                  >
                    <h3>{{ position.game }}</h3>
                    <div class="position-details">
                      <div v-if="position.home_shares > 0" class="shares-info">
                        <span class="label">Home Shares:</span>
                        <span class="value">{{ position.home_shares.toFixed(2) }} @ {{ position.avg_home_price.toFixed(1) }}Â¢</span>
                      </div>
                      <div v-if="position.away_shares > 0" class="shares-info">
                        <span class="label">Away Shares:</span>
                        <span class="value">{{ position.away_shares.toFixed(2) }} @ {{ position.avg_away_price.toFixed(1) }}Â¢</span>
                      </div>
                      <div class="shares-info highlight">
                        <span class="label">Potential Payout:</span>
                        <span class="value">{{ formatTokens(position.potential_payout) }}</span>
                      </div>
                      <div class="sell-actions">
                        <button v-if="position.home_shares > 0" class="sell-btn" @click="openSellModal(position, 'home')">
                          Sell Home ({{ position.home_shares.toFixed(2) }})
                        </button>
                        <button v-if="position.away_shares > 0" class="sell-btn" @click="openSellModal(position, 'away')">
                          Sell Away ({{ position.away_shares.toFixed(2) }})
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Settled Positions -->
              <div v-if="settledPositions.length > 0" class="positions-section">
                <h2 class="section-title">âœ… Settled Positions</h2>
                <div class="positions-grid">
                  <div 
                    v-for="position in settledPositions" 
                    :key="position.market_id"
                    class="position-card settled"
                  >
                    <h3>{{ position.game }}</h3>
                    <div class="position-details">
                      <div v-if="position.home_shares > 0" class="shares-info">
                        <span class="label">Home Shares:</span>
                        <span class="value">{{ position.home_shares.toFixed(2) }}</span>
                      </div>
                      <div v-if="position.away_shares > 0" class="shares-info">
                        <span class="label">Away Shares:</span>
                        <span class="value">{{ position.away_shares.toFixed(2) }}</span>
                      </div>
                      <div class="shares-info highlight">
                        <span class="label">Payout:</span>
                        <span class="value">{{ formatTokens(position.potential_payout) }}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Raffle Tab -->
          <div v-else-if="activeTab === 'raffle'" class="raffle-container">
            <!-- Raffle Token Balance -->
            <div class="raffle-balance-bar">
              <div class="raffle-balance-main">
                <div class="raffle-balance-info">
                  <span class="raffle-balance-label">ðŸŽŸï¸ Your Raffle Tokens</span>
                  <span class="raffle-balance-amount">{{ Math.floor(userRaffleTokens).toLocaleString() }} RT</span>
                </div>
                <p class="raffle-balance-hint">Raffle tokens are earned automatically whenever you place a bet. 1 token wagered = 1 RT earned.</p>
              </div>
              <img src="/static/actian-logo.png" alt="Actian" class="raffle-sponsor-logo">
            </div>

            <div v-if="!isLoggedIn" class="raffle-login-prompt">
              <p>ðŸ” <a href="#" @click.prevent="openAuthModal('login')">Log in</a> to buy raffle tickets and see your entry count.</p>
            </div>

            <!-- Prize Card -->
            <div v-if="raffleData" class="raffle-prize-card">
              <img src="/static/actian-logo.png" alt="Actian" class="prize-logo">
              <div class="prize-info">
                <h2 class="prize-name">{{ raffleData.prize.name }}</h2>
                <p class="prize-desc">{{ raffleData.prize.description }}</p>
              </div>
              <div class="prize-odds">
                <div class="odds-number">{{ raffleData.user_tickets }}</div>
                <div class="odds-label">your tickets</div>
              </div>
            </div>

            <!-- Feedback -->
            <div v-if="raffleSuccess" class="raffle-success">âœ… {{ raffleSuccess }}</div>
            <div v-if="raffleError" class="raffle-error-msg">âŒ {{ raffleError }}</div>

            <!-- Tiers -->
            <div v-if="raffleData" class="raffle-tiers">
              <h3 class="tiers-heading">Buy Tickets</h3>
              <div class="tiers-grid">
                <div v-for="tier in raffleData.tiers" :key="tier.id" class="tier-card">
                  <div v-if="tier.pct_off > 0" class="tier-badge">{{ tier.pct_off }}% OFF</div>
                  <div class="tier-count">{{ tier.tickets }}<span class="tier-unit"> ticket{{ tier.tickets > 1 ? 's' : '' }}</span></div>
                  <div class="tier-label">{{ tier.label }}</div>
                  <div class="tier-cost">{{ tier.cost.toLocaleString() }} RT</div>
                  <div v-if="tier.savings > 0" class="tier-savings">saves {{ tier.savings }} RT</div>
                  <div v-else class="tier-savings-placeholder"></div>
                  <button
                    @click="buyRaffleTickets(tier.id)"
                    :disabled="!isLoggedIn || raffleBuying === tier.id || userRaffleTokens < tier.cost"
                    :class="['tier-buy-btn', { 'cant-afford': isLoggedIn && userRaffleTokens < tier.cost }]"
                  >
                    <span v-if="raffleBuying === tier.id">Buyingâ€¦</span>
                    <span v-else-if="!isLoggedIn">Log in</span>
                    <span v-else-if="userRaffleTokens < tier.cost">Need {{ (tier.cost - Math.floor(userRaffleTokens)).toLocaleString() }} more RT</span>
                    <span v-else>Buy</span>
                  </button>
                </div>
              </div>
            </div>

            <div v-else class="raffle-loading">Loading raffleâ€¦</div>
          </div>

          <!-- Admin Tab -->
          <div v-else-if="activeTab === 'admin'" class="admin-container">
            <h2 class="admin-heading">âš™ï¸ Admin Panel</h2>

            <!-- Raffle Section -->
            <div class="admin-card">
              <h3 class="admin-card-title">ðŸŽŸï¸ Raffle â€” Actian Mystery Swag</h3>
              <div class="admin-raffle-status-row">
                <div v-if="raffleData && raffleData.raffle_closed" class="admin-closed-badge">ðŸ”’ Raffle Closed</div>
                <div v-else class="admin-open-badge">ðŸŸ¢ Raffle Open</div>
                <span class="admin-draws-count" v-if="adminRaffleWinners.length">{{ adminRaffleWinners.length }} winner(s) drawn</span>
              </div>

              <!-- All drawn winners -->
              <div v-if="adminRaffleWinners.length" class="admin-winners-list">
                <div v-for="w in adminRaffleWinners" :key="w.draw_number" class="admin-winner-box">
                  <div class="admin-winner-label">ðŸ† Draw #{{ w.draw_number }}</div>
                  <div class="admin-winner-name">{{ w.username }}</div>
                  <div class="admin-winner-email">ðŸ“§ {{ w.email }}</div>
                  <div class="admin-winner-meta">{{ w.tickets }} ticket(s) &middot; drawn {{ w.drawn_at ? w.drawn_at.slice(0,19).replace('T',' ') : '' }} UTC</div>
                </div>
              </div>

              <div v-if="adminRaffleError" class="admin-error">âŒ {{ adminRaffleError }}</div>

              <div class="admin-raffle-btn-row">
                <button
                  class="admin-btn admin-btn-primary"
                  :disabled="adminRaffleRunning || (raffleData && raffleData.raffle_closed)"
                  @click="adminRunRaffle"
                >
                  <span v-if="adminRaffleRunning">Drawingâ€¦</span>
                  <span v-else-if="raffleData && raffleData.raffle_closed">Raffle Closed</span>
                  <span v-else>ðŸŽ² Draw Winner{{ adminRaffleWinners.length ? ' Again' : '' }}</span>
                </button>

                <button
                  v-if="!(raffleData && raffleData.raffle_closed)"
                  class="admin-btn admin-btn-danger"
                  :disabled="adminRaffleClosing"
                  @click="adminCloseRaffle"
                >
                  <span v-if="adminRaffleClosing">Closingâ€¦</span>
                  <span v-else>ðŸ”’ Close Raffle</span>
                </button>

                <button
                  v-else
                  class="admin-btn admin-btn-outline"
                  :disabled="adminRaffleClosing"
                  @click="adminOpenRaffle"
                >
                  <span v-if="adminRaffleClosing">Openingâ€¦</span>
                  <span v-else>ðŸŸ¢ Reopen Raffle</span>
                </button>
              </div>
            </div>

            <!-- Settle Game Section -->
            <div class="admin-card">
              <h3 class="admin-card-title">ðŸ Settle Game</h3>
              <p class="admin-card-hint">Enter final scores to settle a market and pay out winners.</p>
              <div class="admin-settle-form">
                <div class="admin-form-row">
                  <label class="admin-label">Market</label>
                  <select v-model="adminSettleMarketId" class="admin-select">
                    <option value="">â€” select a market â€”</option>
                    <option v-for="m in adminAllMarkets" :key="m.market_id" :value="m.market_id">
                      {{ m.home_team }} vs {{ m.away_team }} ({{ m.game_date }}) [{{ m.status }}]
                    </option>
                  </select>
                </div>
                <div class="admin-form-scores" v-if="adminSettleMarketId">
                  <div class="admin-score-field">
                    <label class="admin-label">{{ adminAllMarkets.find(m=>m.market_id===adminSettleMarketId)?.home_team || 'Home' }} Score</label>
                    <input type="number" v-model.number="adminSettleHomeScore" min="0" class="admin-score-input" placeholder="0">
                  </div>
                  <div class="admin-score-sep">â€“</div>
                  <div class="admin-score-field">
                    <label class="admin-label">{{ adminAllMarkets.find(m=>m.market_id===adminSettleMarketId)?.away_team || 'Away' }} Score</label>
                    <input type="number" v-model.number="adminSettleAwayScore" min="0" class="admin-score-input" placeholder="0">
                  </div>
                </div>
                <div v-if="adminSettleResult" class="admin-success">âœ… {{ adminSettleResult }}</div>
                <div v-if="adminSettleError" class="admin-error">âŒ {{ adminSettleError }}</div>
                <button
                  class="admin-btn admin-btn-primary"
                  :disabled="adminSettleProcessing || !adminSettleMarketId"
                  @click="adminSettleGame"
                >
                  <span v-if="adminSettleProcessing">Settlingâ€¦</span>
                  <span v-else>ðŸ Settle Game</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Trade Modal -->
          <div v-if="showTradeModal" class="modal-overlay" @click="closeTradeModal">
            <div class="modal" @click.stop>
              <div class="modal-header">
                <h2>Place Prediction</h2>
                <button class="close-btn" @click="closeTradeModal">Ã—</button>
              </div>
              
              <div class="modal-body">
                <div class="market-summary">
                  <h3>{{ selectedMarket.home_team }} vs {{ selectedMarket.away_team }}</h3>
                  <p class="game-time">{{ selectedMarket.game_date }} at {{ selectedMarket.game_time }}</p>
                </div>

                <div class="trade-form">
                  <div class="form-group">
                    <label>Predict Winner</label>
                    <div class="outcome-selector">
                      <button 
                        :class="['outcome-option', { active: tradeOutcome === 'home' }]"
                        @click="tradeOutcome = 'home'"
                      >
                        <div class="team">{{ selectedMarket.home_team }}</div>
                        <div class="elo-badge" v-if="selectedMarket.home_elo != null">Elo {{ selectedMarket.home_elo }}</div>
                        <div class="price">{{ selectedMarket.home_price.toFixed(1) }}Â¢</div>
                      </button>
                      <button 
                        :class="['outcome-option', { active: tradeOutcome === 'away' }]"
                        @click="tradeOutcome = 'away'"
                      >
                        <div class="team">{{ selectedMarket.away_team }}</div>
                        <div class="elo-badge" v-if="selectedMarket.away_elo != null">Elo {{ selectedMarket.away_elo }}</div>
                        <div class="price">{{ selectedMarket.away_price.toFixed(1) }}Â¢</div>
                      </button>
                    </div>
                  </div>

                  <div class="form-group">
                    <label>Amount (tokens)</label>
                    <input 
                      type="number" 
                      v-model.number="tradeAmount"
                      min="1"
                      :max="userBalance"
                      step="10"
                      class="amount-input"
                    >
                    <div class="quick-amounts">
                      <button @click="tradeAmount = 100" class="quick-btn">100</button>
                      <button @click="tradeAmount = 500" class="quick-btn">500</button>
                      <button @click="tradeAmount = 1000" class="quick-btn">1000</button>
                      <button @click="tradeAmount = userBalance" class="quick-btn">Max</button>
                    </div>
                  </div>

                  <div class="trade-summary">
                    <p>You'll receive approximately <strong>{{ (tradeAmount / (tradeOutcome === 'home' ? selectedMarket.home_price : selectedMarket.away_price) * 100).toFixed(2) }}</strong> shares</p>
                    <p class="potential">Potential return: <strong>{{ formatTokens(tradeAmount / (tradeOutcome === 'home' ? selectedMarket.home_price : selectedMarket.away_price) * 100) }}</strong></p>
                  </div>

                  <div v-if="tradeResult" :class="['trade-result', tradeResult.success ? 'success' : 'error']">
                    {{ tradeResult.message }}
                  </div>

                  <button 
                    class="submit-btn" 
                    @click="executeTrade"
                    :disabled="tradeProcessing || tradeAmount <= 0 || tradeAmount > userBalance"
                  >
                    <span v-if="tradeProcessing">Processing...</span>
                    <span v-else>Confirm Prediction</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Sell Modal -->
          <div v-if="showSellModal" class="modal-overlay" @click="closeSellModal">
            <div class="modal" @click.stop>
              <div class="modal-header">
                <h2>Sell Shares</h2>
                <button class="close-btn" @click="closeSellModal">Ã—</button>
              </div>
              <div class="modal-body" v-if="sellPosition && sellMarket">
                <div class="market-summary">
                  <h3>{{ sellMarket.home_team }} vs {{ sellMarket.away_team }}</h3>
                  <p class="game-time">Selling: <strong>{{ sellOutcome === 'home' ? sellMarket.home_team : sellMarket.away_team }}</strong> shares</p>
                </div>
                <div class="trade-form">
                  <div class="form-group">
                    <label>Shares to Sell</label>
                    <input
                      type="number"
                      v-model.number="sellShares"
                      min="0.0001"
                      :max="sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares"
                      step="0.01"
                      class="amount-input"
                      @input="updateSellPreview"
                    >
                    <div class="quick-amounts">
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.25).toFixed(4)); updateSellPreview()" class="quick-btn">25%</button>
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.5).toFixed(4)); updateSellPreview()" class="quick-btn">50%</button>
                      <button @click="sellShares = parseFloat(((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares) * 0.75).toFixed(4)); updateSellPreview()" class="quick-btn">75%</button>
                      <button @click="sellShares = parseFloat((sellOutcome === 'home' ? sellPosition.home_shares : sellPosition.away_shares).toFixed(4)); updateSellPreview()" class="quick-btn">All</button>
                    </div>
                  </div>
                  <div class="trade-summary" v-if="sellPreview !== null">
                    <p>You will receive approximately <strong>{{ sellPreview.toFixed(2) }} ðŸª™</strong></p>
                    <p class="potential" style="color:#e55; font-size:0.85rem;">LMSR sell-back â€” no arbitrage. Actual payout may vary slightly.</p>
                  </div>
                  <div v-if="sellResult" :class="['trade-result', sellResult.success ? 'success' : 'error']">
                    {{ sellResult.message }}
                  </div>
                  <button
                    class="submit-btn"
                    @click="executeSell"
                    :disabled="sellProcessing || sellShares <= 0"
                  >
                    <span v-if="sellProcessing">Processing...</span>
                    <span v-else>Confirm Sell</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Price Chart Modal -->
          <div v-if="showPriceChart" class="modal-overlay" @click="closePriceChart">
            <div class="modal chart-modal" @click.stop>
              <div class="modal-header">
                <h2>ðŸ“ˆ Price History</h2>
                <button class="close-btn" @click="closePriceChart">Ã—</button>
              </div>
              <div class="modal-body">
                <div class="market-summary" v-if="selectedMarket">
                  <h3>{{ selectedMarket.home_team }} vs {{ selectedMarket.away_team }}</h3>
                  <p class="game-time">{{ selectedMarket.game_date }} at {{ selectedMarket.game_time }}</p>
                </div>
                <div class="chart-view-btns">
                  <button :class="['chart-view-btn', { active: chartView === '1h' }]" @click="setChartView('1h')">1H</button>
                  <button :class="['chart-view-btn', { active: chartView === '1d' }]" @click="setChartView('1d')">1D</button>
                  <button :class="['chart-view-btn', { active: chartView === '1w' }]" @click="setChartView('1w')">1W</button>
                </div>
                <div v-show="priceChartData === null" class="chart-loading">Loading history...</div>
                <div v-show="priceChartData !== null && priceChartData.length === 0" class="chart-loading">Could not load price history.</div>
                <div v-show="priceChartData !== null && priceChartData.length > 0" class="chart-container">
                  <canvas ref="priceChartCanvasRef"></canvas>
                </div>
              </div>
            </div>
          </div>

          <!-- Expanded Game View Modal -->
          <div v-if="showExpandedView" class="modal-overlay" @click="closeExpandedView">
            <div class="expanded-game-modal" @click.stop>
              <div class="expanded-header">
                <div class="expanded-title">
                  <span class="sport-badge">{{ expandedMarket.sport }}</span>
                  <h2>{{ expandedMarket.home_team }} vs {{ expandedMarket.away_team }}</h2>
                  <span class="status-badge" :class="getStatusColor(expandedMarket.status)">
                    {{ getStatusIcon(expandedMarket.status) }} {{ getStatusText(expandedMarket.status) }}
                  </span>
                </div>
                <button class="close-btn" @click="closeExpandedView">Ã—</button>
              </div>

              <div class="expanded-body">
                <!-- Top Section: Game Info -->
                <div class="expanded-info-section">
                  <div class="game-details">
                    <div class="info-item">
                      <span class="info-label">ðŸ“… Date:</span>
                      <span class="info-value">{{ expandedMarket.game_date }}</span>
                    </div>
                    <div class="info-item">
                      <span class="info-label">â° Time:</span>
                      <span class="info-value">{{ expandedMarket.game_time }}</span>
                    </div>
                    <div class="info-item">
                      <span class="info-label">ðŸ“Š Volume:</span>
                      <span class="info-value">{{ formatTokens(expandedMarket.total_volume) }}</span>
                    </div>
                    <div v-if="expandedMarket.status === 'settled'" class="info-item">
                      <span class="info-label">ðŸ† Winner:</span>
                      <span class="info-value">
                        {{ expandedMarket.winner === 'home' ? expandedMarket.home_team : expandedMarket.away_team }}
                      </span>
                    </div>
                  </div>

                  <div class="current-odds">
                    <div class="odds-card">
                      <div class="team-name">{{ expandedMarket.home_team }}</div>
                      <div class="elo-badge" v-if="expandedMarket.home_elo != null">Elo {{ expandedMarket.home_elo }}</div>
                      <div class="price-large">{{ expandedMarket.home_price.toFixed(1) }}Â¢</div>
                    </div>
                    <div class="vs-divider">VS</div>
                    <div class="odds-card">
                      <div class="team-name">{{ expandedMarket.away_team }}</div>
                      <div class="elo-badge" v-if="expandedMarket.away_elo != null">Elo {{ expandedMarket.away_elo }}</div>
                      <div class="price-large">{{ expandedMarket.away_price.toFixed(1) }}Â¢</div>
                    </div>
                  </div>
                </div>

                <!-- Bottom Section: Chart + Trading (Left) and Chat (Right) -->
                <div class="expanded-content-grid">
                  <!-- Left: Chart and Trading -->
                  <div class="expanded-chart-section">
                    <div class="section-header">
                      <h3>ðŸ“ˆ Price History</h3>
                      <div class="chart-view-btns">
                        <button :class="['chart-view-btn', { active: expandedChartView === '1h' }]" @click="changeExpandedChartView('1h')">1H</button>
                        <button :class="['chart-view-btn', { active: expandedChartView === '1d' }]" @click="changeExpandedChartView('1d')">1D</button>
                        <button :class="['chart-view-btn', { active: expandedChartView === '1w' }]" @click="changeExpandedChartView('1w')">1W</button>
                      </div>
                    </div>
                    <div class="chart-container-expanded">
                      <canvas :key="expandedChartKey" ref="expandedChartCanvasRef"></canvas>
                    </div>

                    <!-- Trading Options -->
                    <div v-if="expandedMarket.status === 'open'" class="trading-section">
                      <h4>Buy Shares</h4>
                      <div class="trade-buttons">
                        <button class="trade-btn buy-home" @click="buyFromExpandedView('home')">
                          Buy {{ expandedMarket.home_team }}
                        </button>
                        <button class="trade-btn buy-away" @click="buyFromExpandedView('away')">
                          Buy {{ expandedMarket.away_team }}
                        </button>
                      </div>
                      
                      <!-- Sell Options - only show if user has shares -->
                      <div v-if="isLoggedIn && expandedMarketPosition && (expandedMarketPosition.home_shares > 0 || expandedMarketPosition.away_shares > 0)" class="sell-options">
                        <h4>Sell Shares</h4>
                        <div class="trade-buttons">
                          <button v-if="expandedMarketPosition.home_shares > 0" class="trade-btn sell-home" @click="sellFromExpandedView('home')">
                            Sell {{ expandedMarket.home_team }} ({{ expandedMarketPosition.home_shares.toFixed(2) }})
                          </button>
                          <button v-if="expandedMarketPosition.away_shares > 0" class="trade-btn sell-away" @click="sellFromExpandedView('away')">
                            Sell {{ expandedMarket.away_team }} ({{ expandedMarketPosition.away_shares.toFixed(2) }})
                          </button>
                        </div>
                      </div>
                    </div>
                    <div v-else-if="expandedMarket.status === 'closed'" class="trading-section">
                      <p class="status-message">ðŸ”’ Trading is closed for this market</p>
                    </div>
                    <div v-else-if="expandedMarket.status === 'settled'" class="trading-section">
                      <template v-if="expandedMarket.winner === 'push'">
                        <p class="status-message">â†©ï¸ Bet pushed â€“ no result was posted. Your bets have been refunded.</p>
                      </template>
                      <template v-else>
                        <p class="status-message">âœ… Market has been settled</p>
                      </template>
                    </div>
                  </div>

                  <!-- Right: Chat -->
                  <div class="expanded-chat-section">
                    <div class="section-header">
                      <h3>ðŸ’¬ Discussion</h3>
                      <span v-if="expandedMarket.status === 'settled'" class="chat-closed-badge">Closed</span>
                    </div>
                    
                    <div class="chat-messages">
                      <div v-if="chatLoading" class="chat-loading">Loading messages...</div>
                      <div v-else-if="chatMessages.length === 0" class="no-messages">
                        <p>No messages yet. Be the first to comment!</p>
                      </div>
                      <div v-else>
                        <div v-for="msg in chatMessages" :key="msg.message_id"
                             :class="['chat-message', msg.message_type === 'score_report' ? 'score-report-msg' : '']">
                          <template v-if="msg.message_type === 'score_report'">
                            <div class="score-report-label">ðŸ“Š Score Update</div>
                            <div class="score-report-score">{{ msg.message }}</div>
                            <div class="score-report-footer">
                              <div class="score-report-votes">
                                <button @click.stop="voteOnScoreReport(msg.message_id, 'up')"
                                        :class="['vote-btn', 'vote-up', { active: msg.voters && user && msg.voters[user.username] === 'up' }]"
                                        :disabled="!isLoggedIn"
                                        :title="isLoggedIn ? 'Upvote' : 'Log in to vote'">
                                  ðŸ‘ {{ msg.upvotes || 0 }}
                                </button>
                                <button @click.stop="voteOnScoreReport(msg.message_id, 'down')"
                                        :class="['vote-btn', 'vote-down', { active: msg.voters && user && msg.voters[user.username] === 'down' }]"
                                        :disabled="!isLoggedIn"
                                        :title="isLoggedIn ? 'Downvote' : 'Log in to vote'">
                                  ðŸ‘Ž {{ msg.downvotes || 0 }}
                                </button>
                              </div>
                              <span class="score-report-meta">by {{ msg.username }} Â· {{ new Date(msg.timestamp).toLocaleTimeString() }}</span>
                            </div>
                          </template>
                          <template v-else>
                            <div class="message-header">
                              <span class="message-username">{{ msg.username }}</span>
                              <span class="message-time">{{ new Date(msg.timestamp).toLocaleString() }}</span>
                            </div>
                            <div class="message-content">{{ msg.message }}</div>
                          </template>
                        </div>
                      </div>
                    </div>

                    <div v-if="expandedMarket.status !== 'settled'" class="chat-input-section">
                      <div v-if="!isLoggedIn" class="chat-login-prompt">
                        <p>Please <a href="#" @click.prevent="openAuthModal('login')">login</a> to chat</p>
                      </div>
                      <div v-else>
                        <div class="chat-input-container">
                          <input 
                            v-model="chatMessage" 
                            @keyup.enter="sendChatMessage"
                            type="text" 
                            placeholder="Type your message..."
                            class="chat-input"
                            maxlength="500"
                          >
                          <button @click="sendChatMessage" class="send-btn" :disabled="!chatMessage.trim()">Send</button>
                          <button @click="showScoreReport = !showScoreReport" class="score-report-toggle-btn" title="Report current score">ðŸ“Š</button>
                        </div>
                        <div v-if="showScoreReport" class="score-report-form">
                          <div class="score-report-row">
                            <span class="score-team-label">{{ expandedMarket.home_team }}</span>
                            <input v-model="scoreReportHome" type="number" min="0" placeholder="0" class="score-input">
                            <span class="score-sep">â€“</span>
                            <input v-model="scoreReportAway" type="number" min="0" placeholder="0" class="score-input">
                            <span class="score-team-label">{{ expandedMarket.away_team }}</span>
                          </div>
                          <div class="score-report-actions">
                            <button @click="sendScoreReport" class="submit-score-btn" :disabled="scoreReportLoading || scoreReportHome === '' || scoreReportAway === ''">{{ scoreReportLoading ? 'Posting...' : 'Post Score' }}</button>
                            <button @click="showScoreReport = false" class="cancel-score-btn">Cancel</button>
                          </div>
                        </div>
                      </div>
                      <div v-if="chatError" class="chat-error">{{ chatError }}</div>
                    </div>
                    <div v-else class="chat-closed-message">
                      <p>Chat is closed for settled markets</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Auth Modal -->
          <div v-if="showAuthModal" class="modal-overlay" @click="showAuthModal = false">
            <div class="modal auth-modal" @click.stop>
              <div class="modal-header">
                <h2>{{ authMode === 'login' ? 'Login' : 'Register' }}</h2>
                <button class="close-btn" @click="showAuthModal = false">Ã—</button>
              </div>
              
              <div class="modal-body">
                <div class="auth-form">
                  <div class="form-group">
                    <label>Username</label>
                    <input 
                      type="text" 
                      v-model="authUsername"
                      placeholder="Enter username"
                      class="form-input"
                      @keyup.enter="authMode === 'login' ? login() : register()"
                    >
                  </div>

                  <div v-if="authMode === 'register'" class="form-group">
                    <label>Email</label>
                    <input 
                      type="email" 
                      v-model="authEmail"
                      placeholder="Enter email"
                      class="form-input"
                      @keyup.enter="register()"
                    >
                  </div>

                  <div class="form-group">
                    <label>Password</label>
                    <input 
                      type="password" 
                      v-model="authPassword"
                      placeholder="Enter password"
                      class="form-input"
                      @keyup.enter="authMode === 'login' ? login() : register()"
                    >
                  </div>

                  <div v-if="authError" class="auth-error">
                    {{ authError }}
                  </div>

                  <button 
                    class="submit-btn" 
                    @click="authMode === 'login' ? login() : register()"
                    :disabled="authProcessing || !authUsername || !authPassword || (authMode === 'register' && !authEmail)"
                  >
                    <span v-if="authProcessing">Processing...</span>
                    <span v-else>{{ authMode === 'login' ? 'Login' : 'Create Account' }}</span>
                  </button>

                  <div class="auth-switch">
                    <a href="#" @click.prevent="authMode = authMode === 'login' ? 'register' : 'login'">
                      {{ authMode === 'login' ? 'Need an account? Register' : 'Already have an account? Login' }}
                    </a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `
    }).mount('#app');
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      background: white;
      border-radius: 16px;
      padding: 24px 32px;
      margin-bottom: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
    }

    .branding h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
    }

    .subtitle {
      color: #666;
      font-size: 1rem;
    }

    .wallet {
      display: flex;
      gap: 32px;
      align-items: center;
    }

    .user-info {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    .username {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .auth-buttons {
      display: flex;
      gap: 12px;
    }

    .btn-login, .btn-register, .btn-logout {
      padding: 10px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-login {
      background: white;
      color: #667eea;
      border: 2px solid #667eea;
    }

    .btn-login:hover {
      background: #667eea;
      color: white;
    }

    .btn-register {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-register:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .btn-logout {
      background: #ff4444;
      color: white;
      font-size: 0.9rem;
      padding: 6px 16px;
    }

    .btn-logout:hover {
      background: #cc0000;
    }

    .balance, .total-value {
      text-align: right;
    }

    .label {
      display: block;
      font-size: 0.875rem;
      color: #666;
      margin-bottom: 4px;
    }

    .amount {
      display: block;
      font-size: 1.75rem;
      font-weight: 700;
      color: #333;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
    }

    .tab {
      flex: 1;
      padding: 16px;
      background: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .tab.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* Loading & Error */
    .loading, .error, .no-markets, .no-positions {
      background: white;
      padding: 60px 40px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Date Filter Bar (Top) */
    .date-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 24px;
      padding: 20px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      overflow-x: auto;
    }

    .date-chip {
      padding: 10px 20px;
      background: #f5f5f5;
      border: 2px solid transparent;
      border-radius: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      white-space: nowrap;
      font-size: 0.9rem;
    }

    .date-chip:hover {
      background: #e8e8e8;
      border-color: #667eea;
    }

    .date-chip.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    /* Markets Container Layout */
    .markets-container {
      display: flex;
      gap: 24px;
      align-items: flex-start;
    }

    .markets-content {
      flex: 1;
    }

    /* Sport Sidebar (Left) */
    .sport-sidebar {
      width: 200px;
      background: white;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      position: sticky;
      top: 20px;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }

    .sidebar-title {
      font-size: 1rem;
      margin-bottom: 16px;
      color: #333;
      font-weight: 700;
    }

    .sport-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sport-btn {
      padding: 10px 16px;
      background: #f5f5f5;
      border: 2px solid transparent;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-align: left;
      font-size: 0.9rem;
    }

    .sport-btn:hover {
      background: #e8e8e8;
      border-color: #667eea;
    }

    .sport-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    /* Market Section */
    .market-section {
      margin-bottom: 40px;
    }

    .section-title {
      font-size: 1.5rem;
      margin-bottom: 16px;
      color: white;
    }

    .markets-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 20px;
    }

    .market-card {
      background: white;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transition: all 0.3s;
    }

    .market-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }

    .market-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .sport-badge {
      padding: 6px 12px;
      background: #f0f0f0;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      color: #666;
    }

    .status-badge {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
    }

    .status-open {
      background: #d4edda;
      color: #155724;
    }

    .status-closed {
      background: #f8d7da;
      color: #721c24;
    }

    .status-settled {
      background: #d1ecf1;
      color: #0c5460;
    }

    .matchup h3 {
      font-size: 1.25rem;
      margin-bottom: 8px;
      color: #333;
    }

    .game-info {
      display: flex;
      gap: 16px;
      font-size: 0.875rem;
      color: #666;
      margin-bottom: 16px;
    }

    .odds-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .odds-section.disabled {
      opacity: 0.6;
    }

    .outcome-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      transition: all 0.3s;
    }

    .outcome-card.home {
      border: 2px solid #667eea;
    }

    .outcome-card.away {
      border: 2px solid #764ba2;
    }

    .team-name {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 4px;
      color: #333;
    }

    .elo-badge {
      font-size: 0.72rem;
      font-weight: 600;
      color: #764ba2;
      background: rgba(118, 75, 162, 0.1);
      border-radius: 4px;
      padding: 2px 6px;
      margin-bottom: 8px;
      display: inline-block;
    }

    .price {
      font-size: 1.75rem;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 12px;
    }

    .buy-btn {
      width: 100%;
      padding: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .buy-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .market-stats {
      font-size: 0.875rem;
      color: #666;
      padding-top: 12px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .settlement-info {
      margin-top: 16px;
    }

    .winner-banner {
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      font-weight: 700;
      font-size: 1.1rem;
    }

    .winner-banner.home {
      background: linear-gradient(135deg, #667eea20, #667eea40);
      color: #667eea;
    }

    .winner-banner.away {
      background: linear-gradient(135deg, #764ba220, #764ba240);
      color: #764ba2;
    }

    .winner-banner.push {
      background: linear-gradient(135deg, #f3f4f620, #e5e7eb40);
      color: #6b7280;
      border: 2px dashed #d1d5db;
    }

    .trophy {
      font-size: 1.5rem;
      margin-right: 8px;
    }

    .final-score {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 12px;
      font-size: 1.8rem;
      font-weight: 700;
    }

    .final-score .score {
      padding: 8px 16px;
      border-radius: 8px;
      background: #f0f0f0;
    }

    .final-score .score.winner {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
    }

    .final-score .score.loser {
      background: #e9ecef;
      color: #6c757d;
    }

    .final-score .score-separator {
      color: #999;
    }

    /* Portfolio */
    .portfolio-container {
      background: white;
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .positions-section {
      margin-bottom: 40px;
    }

    .positions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 20px;
    }

    .position-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      border-left: 4px solid #667eea;
    }

    .position-card.settled {
      border-left-color: #28a745;
    }

    .position-card h3 {
      font-size: 1.1rem;
      margin-bottom: 16px;
      color: #333;
    }

    .position-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .shares-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.95rem;
    }

    .shares-info.highlight {
      font-weight: 700;
      font-size: 1.05rem;
      color: #667eea;
    }

    .sell-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .sell-btn {
      flex: 1;
      padding: 8px 14px;
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
    }

    .sell-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(234,88,12,0.35);
    }

    .chart-btn {
      background: none;
      border: 1px solid #667eea;
      color: #667eea;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .chart-btn:hover {
      background: #667eea;
      color: white;
    }

    .chart-modal {
      max-width: 700px !important;
    }

    .chart-container {
      height: 320px;
      position: relative;
    }

    .chart-loading {
      text-align: center;
      color: #888;
      padding: 40px 0;
      font-size: 1rem;
    }

    .chart-view-btns {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-bottom: 10px;
    }

    .chart-view-btn {
      padding: 4px 14px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      background: white;
      color: #555;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }

    .chart-view-btn:hover {
      border-color: #667eea;
      color: #667eea;
    }

    .chart-view-btn.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal {
      background: white;
      border-radius: 16px;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px;
      border-bottom: 1px solid #e0e0e0;
    }

    .modal-header h2 {
      font-size: 1.5rem;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 2rem;
      cursor: pointer;
      color: #666;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .close-btn:hover {
      background: #f0f0f0;
    }

    .modal-body {
      padding: 24px;
    }

    .market-summary {
      text-align: center;
      margin-bottom: 24px;
      padding-bottom: 24px;
      border-bottom: 1px solid #e0e0e0;
    }

    .market-summary h3 {
      font-size: 1.25rem;
      margin-bottom: 8px;
      color: #333;
    }

    .game-time {
      color: #666;
      font-size: 0.95rem;
    }

    .trade-form {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 12px;
      color: #333;
    }

    .outcome-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .outcome-option {
      padding: 20px;
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }

    .outcome-option:hover {
      border-color: #667eea;
    }

    .outcome-option.active {
      border-color: #667eea;
      background: linear-gradient(135deg, #667eea10, #764ba210);
    }

    .outcome-option .team {
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }

    .outcome-option .price {
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
    }

    .amount-input {
      width: 100%;
      padding: 16px;
      font-size: 1.25rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      transition: all 0.3s;
    }

    .amount-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .quick-amounts {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .quick-btn {
      flex: 1;
      padding: 10px;
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .quick-btn:hover {
      background: #667eea;
      color: white;
    }

    .trade-summary {
      padding: 16px;
      background: #f8f9fa;
      border-radius: 12px;
      text-align: center;
    }

    .trade-summary p {
      margin-bottom: 8px;
      color: #666;
    }

    .trade-summary .potential {
      font-size: 1.1rem;
      color: #28a745;
    }

    .trade-result {
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      font-weight: 600;
    }

    .trade-result.success {
      background: #d4edda;
      color: #155724;
    }

    .trade-result.error {
      background: #f8d7da;
      color: #721c24;
    }

    .submit-btn {
      width: 100%;
      padding: 18px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
    }

    .submit-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
    }

    .submit-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Auth Modal */
    .auth-modal {
      max-width: 400px;
    }

    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .form-input {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.3s;
    }

    .form-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .auth-error {
      padding: 12px;
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 8px;
      color: #c00;
      font-size: 0.9rem;
    }

    .auth-switch {
      text-align: center;
      padding-top: 12px;
    }

    .auth-switch a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
    }

    .auth-switch a:hover {
      text-decoration: underline;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .header-content {
        flex-direction: column;
        text-align: center;
      }

      .wallet {
        width: 100%;
        justify-content: space-around;
      }

      .branding h1 {
        font-size: 2rem;
      }

      .date-filter-bar {
        padding: 15px;
      }

      .date-chip {
        font-size: 0.85rem;
        padding: 8px 16px;
      }

      .markets-container {
        flex-direction: column;
      }

      .sport-sidebar {
        width: 100%;
        position: static;
        max-height: none;
      }

      .sport-list {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .markets-grid, .positions-grid {
        grid-template-columns: 1fr;
      }

      .tabs {
        flex-direction: column;
      }
    }

    /* Clickable Market Cards */
    .market-card.clickable {
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .market-card.clickable:hover {
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }

    .expand-hint {
      font-size: 0.85rem;
      color: #667eea;
      font-weight: 600;
    }

    /* Expanded Game View Modal */
    .expanded-game-modal {
      background: white;
      border-radius: 20px;
      width: 95%;
      max-width: 1400px;
      max-height: 95vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .expanded-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      border-bottom: 2px solid #f0f0f0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .expanded-title {
      display: flex;
      align-items: center;
      gap: 16px;
      flex: 1;
    }

    .expanded-title h2 {
      margin: 0;
      font-size: 1.3rem;
    }

    .expanded-title .sport-badge {
      background: rgba(255,255,255,0.3);
      color: white;
      border: 1px solid rgba(255,255,255,0.5);
    }

    .expanded-title .status-badge {
      background: rgba(255,255,255,0.2);
      color: white;
    }

    .expanded-body {
      overflow-y: auto;
      flex: 1;
      padding: 16px 24px;
    }

    .expanded-info-section {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 20px;
      margin-bottom: 16px;
      padding: 16px;
      background: #f9f9f9;
      border-radius: 12px;
    }

    .game-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .info-label {
      font-size: 0.75rem;
      color: #666;
      font-weight: 600;
    }

    .info-value {
      font-size: 0.95rem;
      color: #333;
      font-weight: 700;
    }

    .current-odds {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .odds-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 12px 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-width: 120px;
    }

    .odds-card .team-name {
      font-weight: 700;
      font-size: 0.85rem;
      text-align: center;
    }

    .price-large {
      font-size: 1.6rem;
      font-weight: 800;
      color: #667eea;
    }

    .vs-divider {
      font-weight: 800;
      font-size: 1.2rem;
      color: #999;
    }

    .expanded-content-grid {
      display: grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 16px;
      height: calc(95vh - 340px);
    }

    .expanded-chart-section,
    .expanded-chat-section {
      background: white;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #f0f0f0;
    }

    .section-header h3 {
      margin: 0;
      font-size: 1rem;
      color: #333;
    }

    .chart-container-expanded {
      flex: 1;
      min-height: 200px;
      margin-bottom: 12px;
    }

    .trading-section {
      padding-top: 12px;
      border-top: 2px solid #f0f0f0;
    }

    .trading-section h4 {
      margin: 0 0 10px 0;
      font-size: 0.95rem;
      color: #333;
    }

    .trade-buttons {
      display: flex;
      gap: 8px;
    }

    .trade-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .trade-btn.buy-home {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .trade-btn.buy-away {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .trade-btn.sell-home,
    .trade-btn.sell-away {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      color: white;
    }

    .trade-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .sell-options {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 2px solid #f0f0f0;
    }

    .sell-options h4 {
      margin: 0 0 10px 0;
      font-size: 0.95rem;
      color: #333;
    }

    .status-message {
      text-align: center;
      padding: 12px;
      color: #666;
      font-weight: 600;
      font-size: 0.9rem;
    }

    /* Chat Section */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      padding: 12px;
      background: #f9f9f9;
      border-radius: 12px;
    }

    .chat-loading,
    .no-messages {
      text-align: center;
      padding: 20px 12px;
      color: #999;
      font-size: 0.9rem;
    }

    .chat-message {
      background: white;
      padding: 8px 12px;
      border-radius: 10px;
      margin-bottom: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .message-username {
      font-weight: 700;
      color: #667eea;
      font-size: 0.85rem;
    }

    .message-time {
      font-size: 0.7rem;
      color: #999;
    }

    .message-content {
      color: #333;
      line-height: 1.4;
      word-wrap: break-word;
      font-size: 0.9rem;
    }

    .chat-input-section {
      border-top: 2px solid #f0f0f0;
      padding-top: 12px;
    }

    .chat-login-prompt {
      text-align: center;
      padding: 12px;
      background: #f9f9f9;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .chat-login-prompt a {
      color: #667eea;
      font-weight: 700;
      text-decoration: none;
    }

    .chat-login-prompt a:hover {
      text-decoration: underline;
    }

    .chat-input-container {
      display: flex;
      gap: 8px;
    }

    .chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 0.9rem;
      transition: border-color 0.3s;
    }

    .score-report-msg {
      background: linear-gradient(135deg, #fff8e1, #fff3cd) !important;
      border-left: 4px solid #f59e0b !important;
      padding: 10px 12px !important;
    }

    .score-report-label {
      font-size: 0.72rem;
      font-weight: 700;
      color: #b45309;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }

    .score-report-score {
      font-size: 1.05rem;
      font-weight: 800;
      color: #1a1a1a;
      letter-spacing: 0.02em;
    }

    .score-report-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 6px;
      gap: 8px;
    }

    .score-report-meta {
      font-size: 0.7rem;
      color: #999;
    }

    .score-report-votes {
      display: flex;
      gap: 6px;
    }

    .vote-btn {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 3px 9px;
      border-radius: 20px;
      border: 2px solid #e5e7eb;
      background: white;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s;
      color: #6b7280;
    }

    .vote-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .vote-btn:not(:disabled):hover {
      border-color: #d1d5db;
      background: #f9fafb;
    }

    .vote-btn.vote-up.active {
      background: #d1fae5;
      border-color: #34d399;
      color: #065f46;
    }

    .vote-btn.vote-down.active {
      background: #fee2e2;
      border-color: #f87171;
      color: #991b1b;
    }

    .score-report-toggle-btn {
      padding: 8px 10px;
      background: #fff8e1;
      border: 2px solid #f59e0b;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .score-report-toggle-btn:hover {
      background: #fef3c7;
    }

    .score-report-form {
      margin-top: 10px;
      padding: 12px;
      background: #fff8e1;
      border: 2px solid #f59e0b;
      border-radius: 10px;
    }

    .score-report-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .score-team-label {
      font-size: 0.8rem;
      font-weight: 700;
      color: #374151;
      flex: 1;
      min-width: 60px;
    }

    .score-input {
      width: 52px;
      padding: 6px 8px;
      border: 2px solid #f59e0b;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 700;
      text-align: center;
      background: white;
    }

    .score-input:focus {
      outline: none;
      border-color: #d97706;
    }

    .score-sep {
      font-weight: 800;
      font-size: 1rem;
      color: #6b7280;
    }

    .score-report-actions {
      display: flex;
      gap: 8px;
    }

    .submit-score-btn {
      flex: 1;
      padding: 7px 14px;
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 7px;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .submit-score-btn:hover:not(:disabled) {
      background: #d97706;
    }

    .submit-score-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .cancel-score-btn {
      padding: 7px 14px;
      background: white;
      color: #6b7280;
      border: 2px solid #e5e7eb;
      border-radius: 7px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .cancel-score-btn:hover {
      background: #f9fafb;
    }

    .chat-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .send-btn {
      padding: 8px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 700;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .send-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-error {
      margin-top: 8px;
      padding: 8px 12px;
      background: #ffe0e0;
      color: #cc0000;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .chat-closed-badge {
      background: #ffcc00;
      color: #333;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 700;
    }

    .chat-closed-message {
      text-align: center;
      padding: 20px;
      color: #999;
      font-style: italic;
    }

    /* Responsive adjustments for expanded view */
    @media (max-width: 1024px) {
      .expanded-content-grid {
        grid-template-columns: 1fr;
      }

      .expanded-info-section {
        grid-template-columns: 1fr;
      }

      .current-odds {
        justify-content: center;
      }
    }

    @media (max-width: 768px) {
      .expanded-game-modal {
        width: 98%;
        max-height: 95vh;
      }

      .expanded-header {
        padding: 16px 20px;
      }

      .expanded-body {
        padding: 16px 20px;
      }

      .expanded-title {
        flex-wrap: wrap;
      }

      .expanded-title h2 {
        font-size: 1.2rem;
      }
    }

    /* ===== RAFFLE TAB ===== */
    .raffle-container {
      max-width: 860px;
      margin: 0 auto;
      padding: 24px 16px;
    }

    .raffle-balance-bar {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      padding: 20px 24px;
      color: white;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .raffle-balance-main {
      flex: 1;
    }

    .raffle-sponsor-logo {
      height: 36px;
      width: auto;
      object-fit: contain;
      filter: brightness(0) invert(1);
      opacity: 0.9;
      flex-shrink: 0;
    }

    .raffle-balance-info {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .raffle-balance-label {
      font-size: 1rem;
      font-weight: 600;
      opacity: 0.9;
    }

    .raffle-balance-amount {
      font-size: 1.8rem;
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .raffle-balance-hint {
      font-size: 0.8rem;
      opacity: 0.75;
      margin: 0;
    }

    .raffle-login-prompt {
      text-align: center;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      margin-bottom: 20px;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .raffle-login-prompt a {
      color: #667eea;
      font-weight: 700;
      text-decoration: none;
    }

    .raffle-prize-card {
      display: flex;
      align-items: center;
      gap: 20px;
      background: linear-gradient(135deg, #fff8e1 0%, #fef3c7 100%);
      border: 2px solid #f59e0b;
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 24px;
    }

    .prize-logo {
      height: 56px;
      width: auto;
      object-fit: contain;
      flex-shrink: 0;
      border-radius: 8px;
      background: white;
      padding: 6px 10px;
    }

    .prize-info {
      flex: 1;
    }

    .prize-name {
      font-size: 1.3rem;
      font-weight: 900;
      color: #92400e;
      margin: 0 0 6px;
    }

    .prize-desc {
      font-size: 0.9rem;
      color: #78350f;
      margin: 0;
      line-height: 1.5;
    }

    .prize-odds {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: white;
      border-radius: 12px;
      padding: 12px 18px;
      border: 2px solid #f59e0b;
      flex-shrink: 0;
      gap: 2px;
      min-width: 80px;
      text-align: center;
    }

    .odds-number {
      font-size: 1.5rem;
      font-weight: 900;
      color: #92400e;
      line-height: 1;
    }

    .odds-label {
      font-size: 0.65rem;
      color: #b45309;
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 0.05em;
    }

    .odds-divider {
      font-size: 1rem;
      color: #d97706;
      font-weight: 700;
      line-height: 1;
    }

    .raffle-success {
      background: #d1fae5;
      color: #065f46;
      border: 2px solid #34d399;
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .raffle-error-msg {
      background: #fee2e2;
      color: #991b1b;
      border: 2px solid #f87171;
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .tiers-heading {
      font-size: 1.1rem;
      font-weight: 800;
      color: #1a1a2e;
      margin: 0 0 16px;
    }

    .tiers-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 14px;
    }

    @media (max-width: 700px) {
      .tiers-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .tier-card {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 16px;
      padding: 20px 16px;
      text-align: center;
      position: relative;
      transition: border-color 0.2s, transform 0.2s;
    }

    .tier-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
    }

    .tier-badge {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 0.7rem;
      font-weight: 800;
      padding: 3px 10px;
      border-radius: 20px;
      white-space: nowrap;
    }

    .tier-count {
      font-size: 2rem;
      font-weight: 900;
      color: #1a1a2e;
      line-height: 1;
      margin-bottom: 4px;
    }

    .tier-unit {
      font-size: 0.85rem;
      font-weight: 600;
      color: #6b7280;
    }

    .tier-label {
      font-size: 0.8rem;
      color: #9ca3af;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
    }

    .tier-cost {
      font-size: 1.1rem;
      font-weight: 800;
      color: #667eea;
      margin-bottom: 4px;
    }

    .tier-savings {
      font-size: 0.75rem;
      color: #16a34a;
      font-weight: 700;
      margin-bottom: 14px;
    }

    .tier-savings-placeholder {
      height: 18px;
      margin-bottom: 14px;
    }

    .tier-buy-btn {
      width: 100%;
      padding: 9px 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      font-size: 0.85rem;
      cursor: pointer;
      transition: opacity 0.2s, transform 0.15s;
    }

    .tier-buy-btn:hover:not(:disabled) {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .tier-buy-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .tier-buy-btn.cant-afford {
      background: #e5e7eb;
      color: #9ca3af;
    }

    .raffle-loading {
      text-align: center;
      padding: 40px;
      color: #9ca3af;
    }

    /* ======= ADMIN PANEL ======= */
    .tab-admin { background: #1a1a2e !important; color: #f59e0b !important; }
    .tab-admin.active { background: #0f0f1a !important; border-bottom-color: #f59e0b !important; }

    .admin-container {
      max-width: 680px;
      margin: 0 auto;
      padding: 24px 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .admin-heading {
      font-size: 1.4rem;
      font-weight: 800;
      color: #1a1a2e;
      margin: 0 0 4px;
    }

    .admin-card {
      background: white;
      border-radius: 14px;
      padding: 20px 24px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .admin-card-title {
      font-size: 1.05rem;
      font-weight: 700;
      color: #1a1a2e;
      margin: 0;
    }

    .admin-card-hint {
      font-size: 0.85rem;
      color: #6b7280;
      margin: -8px 0 0;
    }

    .admin-closed-badge {
      display: inline-block;
      background: #fef3c7;
      color: #92400e;
      font-size: 0.8rem;
      font-weight: 700;
      padding: 4px 12px;
      border-radius: 20px;
      width: fit-content;
    }

    .admin-open-badge {
      display: inline-block;
      background: #dcfce7;
      color: #15803d;
      font-size: 0.8rem;
      font-weight: 700;
      padding: 4px 12px;
      border-radius: 20px;
      width: fit-content;
    }

    .admin-raffle-status-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .admin-draws-count {
      font-size: 0.82rem;
      color: #6b7280;
      font-weight: 600;
    }

    .admin-raffle-btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .admin-winners-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .admin-btn-outline {
      background: white;
      color: #374151;
      border: 2px solid #d1d5db;
    }

    .admin-btn-outline:hover:not(:disabled) {
      border-color: #9ca3af;
    }

    .admin-winner-box {
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      border: 1px solid #86efac;
      border-radius: 10px;
      padding: 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .admin-winner-label {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #15803d;
    }

    .admin-winner-name {
      font-size: 1.3rem;
      font-weight: 800;
      color: #14532d;
    }

    .admin-winner-email {
      font-size: 0.95rem;
      color: #166534;
      font-weight: 600;
    }

    .admin-winner-meta {
      font-size: 0.8rem;
      color: #6b7280;
      margin-top: 4px;
    }

    .admin-btn {
      padding: 10px 22px;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: opacity 0.15s;
      width: fit-content;
    }

    .admin-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .admin-btn-primary {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
    }

    .admin-btn-danger {
      background: linear-gradient(135deg, #ef4444, #b91c1c);
      color: white;
    }

    .admin-error {
      background: #fef2f2;
      border: 1px solid #fca5a5;
      color: #991b1b;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.85rem;
    }

    .admin-success {
      background: #f0fdf4;
      border: 1px solid #86efac;
      color: #15803d;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.85rem;
    }

    .admin-settle-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .admin-form-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .admin-label {
      font-size: 0.8rem;
      font-weight: 600;
      color: #374151;
    }

    .admin-select {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 0.9rem;
      background: white;
      color: #1a1a2e;
      width: 100%;
    }

    .admin-form-scores {
      display: flex;
      align-items: flex-end;
      gap: 14px;
    }

    .admin-score-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
    }

    .admin-score-input {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: 700;
      text-align: center;
      width: 100%;
    }

    .admin-score-sep {
      font-size: 1.5rem;
      font-weight: 800;
      color: #6b7280;
      padding-bottom: 6px;
    }
  </style>
</body>
</html>
